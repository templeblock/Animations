// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_c5728fd05c542abe
#define INCLUDED_c5728fd05c542abe
#include "cpp_float32array.h"
#endif
#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_iron_data_CameraData
#include <iron/data/CameraData.h>
#endif
#ifndef INCLUDED_iron_data_Data
#include <iron/data/Data.h>
#endif
#ifndef INCLUDED_iron_data_Geometry
#include <iron/data/Geometry.h>
#endif
#ifndef INCLUDED_iron_data_MeshData
#include <iron/data/MeshData.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Plane
#include <iron/math/Plane.h>
#endif
#ifndef INCLUDED_iron_math_Ray
#include <iron/math/Ray.h>
#endif
#ifndef INCLUDED_iron_math_RayCaster
#include <iron/math/RayCaster.h>
#endif
#ifndef INCLUDED_iron_math_Vec2
#include <iron/math/Vec2.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <iron/math/Vec4.h>
#endif
#ifndef INCLUDED_iron_object_CameraObject
#include <iron/object/CameraObject.h>
#endif
#ifndef INCLUDED_iron_object_MeshObject
#include <iron/object/MeshObject.h>
#endif
#ifndef INCLUDED_iron_object_Object
#include <iron/object/Object.h>
#endif
#ifndef INCLUDED_iron_object_Transform
#include <iron/object/Transform.h>
#endif
#ifndef INCLUDED_kha_System
#include <kha/System.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix4
#include <kha/math/FastMatrix4.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_11_getRay,"iron.math.RayCaster","getRay",0x534377cc,"iron.math.RayCaster.getRay","iron/math/RayCaster.hx",11,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_29_getDirection,"iron.math.RayCaster","getDirection",0x11ce99a1,"iron.math.RayCaster.getDirection","iron/math/RayCaster.hx",29,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_46_boxIntersect,"iron.math.RayCaster","boxIntersect",0x0520242c,"iron.math.RayCaster.boxIntersect","iron/math/RayCaster.hx",46,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_55_closestBoxIntersect,"iron.math.RayCaster","closestBoxIntersect",0x17c84175,"iron.math.RayCaster.closestBoxIntersect","iron/math/RayCaster.hx",55,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_81_planeIntersect,"iron.math.RayCaster","planeIntersect",0x474337bb,"iron.math.RayCaster.planeIntersect","iron/math/RayCaster.hx",81,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_94_getPlaneUV,"iron.math.RayCaster","getPlaneUV",0x5fafd29f,"iron.math.RayCaster.getPlaneUV","iron/math/RayCaster.hx",94,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_26_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",26,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_27_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",27,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_28_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",28,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_91_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",91,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_92_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",92,0xe076e448)
HX_LOCAL_STACK_FRAME(_hx_pos_ddaf8f915c13665f_93_boot,"iron.math.RayCaster","boot",0x17d0870a,"iron.math.RayCaster.boot","iron/math/RayCaster.hx",93,0xe076e448)
namespace iron{
namespace math{

void RayCaster_obj::__construct() { }

Dynamic RayCaster_obj::__CreateEmpty() { return new RayCaster_obj; }

void *RayCaster_obj::_hx_vtable = 0;

Dynamic RayCaster_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< RayCaster_obj > _hx_result = new RayCaster_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool RayCaster_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x555597fe;
}

 ::iron::math::Ray RayCaster_obj::getRay(Float inputX,Float inputY, ::iron::object::CameraObject camera){
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_11_getRay)
HXLINE(  12)		 ::iron::math::Vec4 start =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  13)		 ::iron::math::Vec4 end =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  14)		::iron::math::RayCaster_obj::getDirection(start,end,inputX,inputY,camera);
HXLINE(  17)		end->sub(start);
HXLINE(  18)		end->normalize();
HXLINE(  19)		 ::iron::math::Vec4 end1 = end;
HXDLIN(  19)		end1->x = (end1->x * ( (float)(camera->data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) ));
HXLINE(  20)		 ::iron::math::Vec4 end2 = end;
HXDLIN(  20)		end2->y = (end2->y * ( (float)(camera->data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) ));
HXLINE(  21)		 ::iron::math::Vec4 end3 = end;
HXDLIN(  21)		end3->z = (end3->z * ( (float)(camera->data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) ));
HXLINE(  23)		return  ::iron::math::Ray_obj::__alloc( HX_CTX ,start,end);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(RayCaster_obj,getRay,return )

 ::iron::math::Mat4 RayCaster_obj::VPInv;

 ::iron::math::Mat4 RayCaster_obj::PInv;

 ::iron::math::Mat4 RayCaster_obj::VInv;

void RayCaster_obj::getDirection( ::iron::math::Vec4 start, ::iron::math::Vec4 end,Float inputX,Float inputY, ::iron::object::CameraObject camera){
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_29_getDirection)
HXLINE(  32)		start->x = ((((Float)inputX / (Float)::kha::System_obj::windowWidth(null())) * ((Float)2.0)) - ((Float)1.0));
HXLINE(  33)		start->y = -(((((Float)inputY / (Float)::kha::System_obj::windowHeight(null())) * ((Float)2.0)) - ((Float)1.0)));
HXLINE(  34)		start->z = ((Float)-1.0);
HXLINE(  35)		end->x = start->x;
HXLINE(  36)		end->y = start->y;
HXLINE(  37)		end->z = ((Float)1.0);
HXLINE(  39)		::iron::math::RayCaster_obj::PInv->getInverse(camera->P);
HXLINE(  40)		::iron::math::RayCaster_obj::VInv->getInverse(camera->V);
HXLINE(  41)		::iron::math::RayCaster_obj::VPInv->multmats(::iron::math::RayCaster_obj::VInv,::iron::math::RayCaster_obj::PInv);
HXLINE(  42)		start->applyproj(::iron::math::RayCaster_obj::VPInv);
HXLINE(  43)		end->applyproj(::iron::math::RayCaster_obj::VPInv);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(RayCaster_obj,getDirection,(void))

 ::iron::math::Vec4 RayCaster_obj::boxIntersect( ::iron::object::Transform transform,Float inputX,Float inputY, ::iron::object::CameraObject camera){
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_46_boxIntersect)
HXLINE(  47)		 ::iron::math::Ray ray = ::iron::math::RayCaster_obj::getRay(inputX,inputY,camera);
HXLINE(  49)		 ::iron::object::Transform t = transform;
HXLINE(  50)		 ::iron::math::Vec4 c =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,t->world->self->_30,t->world->self->_31,t->world->self->_32,null());
HXLINE(  51)		 ::iron::math::Vec4 s =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,t->dim->x,t->dim->y,t->dim->z,null());
HXLINE(  52)		return ray->intersectBox(c,s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RayCaster_obj,boxIntersect,return )

 ::iron::object::Transform RayCaster_obj::closestBoxIntersect(::Array< ::Dynamic> transforms,Float inputX,Float inputY, ::iron::object::CameraObject camera){
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_55_closestBoxIntersect)
HXLINE(  56)		::Array< ::Dynamic> intersects = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  59)		{
HXLINE(  59)			int _g = (int)0;
HXDLIN(  59)			while((_g < transforms->length)){
HXLINE(  59)				 ::iron::object::Transform t = transforms->__get(_g).StaticCast<  ::iron::object::Transform >();
HXDLIN(  59)				_g = (_g + (int)1);
HXLINE(  60)				 ::iron::math::Vec4 intersect = ::iron::math::RayCaster_obj::boxIntersect(t,inputX,inputY,camera);
HXLINE(  61)				if (hx::IsNotNull( intersect )) {
HXLINE(  61)					intersects->push(t);
            				}
            			}
            		}
HXLINE(  65)		if ((intersects->length == (int)0)) {
HXLINE(  65)			return null();
            		}
HXLINE(  68)		 ::iron::object::Transform closest = null();
HXLINE(  69)		Float minDist = ::Math_obj::POSITIVE_INFINITY;
HXLINE(  70)		{
HXLINE(  70)			int _g1 = (int)0;
HXDLIN(  70)			while((_g1 < intersects->length)){
HXLINE(  70)				 ::iron::object::Transform t1 = intersects->__get(_g1).StaticCast<  ::iron::object::Transform >();
HXDLIN(  70)				_g1 = (_g1 + (int)1);
HXLINE(  71)				 ::iron::math::Vec4 v1 = t1->loc;
HXDLIN(  71)				 ::iron::math::Vec4 v2 = camera->transform->loc;
HXDLIN(  71)				float vx = (v1->x - v2->x);
HXDLIN(  71)				float vy = (v1->y - v2->y);
HXDLIN(  71)				float vz = (v1->z - v2->z);
HXDLIN(  71)				float dist = ::Math_obj::sqrt((((vx * vx) + (vy * vy)) + (vz * vz)));
HXLINE(  72)				if ((dist < minDist)) {
HXLINE(  73)					minDist = dist;
HXLINE(  74)					closest = t1;
            				}
            			}
            		}
HXLINE(  78)		return closest;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RayCaster_obj,closestBoxIntersect,return )

 ::iron::math::Vec4 RayCaster_obj::planeIntersect( ::iron::math::Vec4 normal, ::iron::math::Vec4 a,Float inputX,Float inputY, ::iron::object::CameraObject camera){
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_81_planeIntersect)
HXLINE(  82)		 ::iron::math::Ray ray = ::iron::math::RayCaster_obj::getRay(inputX,inputY,camera);
HXLINE(  84)		 ::iron::math::Plane plane =  ::iron::math::Plane_obj::__alloc( HX_CTX );
HXLINE(  85)		plane->set(normal,a);
HXLINE(  87)		return ray->intersectPlane(plane);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC5(RayCaster_obj,planeIntersect,return )

 ::iron::math::Vec4 RayCaster_obj::loc;

 ::iron::math::Vec4 RayCaster_obj::nor;

 ::iron::math::Mat4 RayCaster_obj::m;

 ::iron::math::Vec2 RayCaster_obj::getPlaneUV( ::iron::object::MeshObject obj,Float screenX,Float screenY, ::iron::object::CameraObject camera){
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_94_getPlaneUV)
HXLINE(  96)		 ::kha::arrays::Float32ArrayPrivate normals = obj->data->geom->normals;
HXLINE(  97)		 ::iron::math::Vec4 _hx_tmp = ::iron::math::RayCaster_obj::nor;
HXDLIN(  97)		float _hx_tmp1 = normals->self.get((int)0);
HXDLIN(  97)		float _hx_tmp2 = normals->self.get((int)1);
HXDLIN(  97)		_hx_tmp->set(_hx_tmp1,_hx_tmp2,normals->self.get((int)2),null());
HXLINE( 101)		::iron::math::RayCaster_obj::m->setFrom(obj->transform->world);
HXLINE( 102)		::iron::math::RayCaster_obj::m->getInverse(::iron::math::RayCaster_obj::m);
HXLINE( 103)		::iron::math::RayCaster_obj::m->transpose3x3();
HXLINE( 104)		::iron::math::RayCaster_obj::m->self->_30 = (::iron::math::RayCaster_obj::m->self->_31 = (::iron::math::RayCaster_obj::m->self->_32 = (int)0));
HXLINE( 105)		::iron::math::RayCaster_obj::nor->applymat(::iron::math::RayCaster_obj::m);
HXLINE( 106)		::iron::math::RayCaster_obj::nor->normalize();
HXLINE( 109)		::iron::math::RayCaster_obj::loc->set(obj->transform->world->self->_30,obj->transform->world->self->_31,obj->transform->world->self->_32,null());
HXLINE( 110)		 ::iron::math::Vec4 hit = ::iron::math::RayCaster_obj::planeIntersect(::iron::math::RayCaster_obj::nor,::iron::math::RayCaster_obj::loc,screenX,screenY,camera);
HXLINE( 113)		if (hx::IsNotNull( hit )) {
HXLINE( 114)			float a = ::iron::math::RayCaster_obj::nor->x;
HXLINE( 115)			float b = ::iron::math::RayCaster_obj::nor->y;
HXLINE( 116)			float c = ::iron::math::RayCaster_obj::nor->z;
HXLINE( 117)			Float e = ((Float)0.0001);
HXLINE( 118)			 ::iron::math::Vec4 u;
HXDLIN( 118)			bool u1;
HXDLIN( 118)			if ((a >= e)) {
HXLINE( 118)				u1 = (b >= e);
            			}
            			else {
HXLINE( 118)				u1 = false;
            			}
HXDLIN( 118)			if (u1) {
HXLINE( 118)				u =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,b,-(a),(int)0,null());
            			}
            			else {
HXLINE( 118)				u =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,c,-(a),(int)0,null());
            			}
HXLINE( 119)			u->normalize();
HXLINE( 120)			 ::iron::math::Vec4 v = ::iron::math::RayCaster_obj::nor->clone();
HXLINE( 121)			v->cross(u);
HXLINE( 123)			hit->sub(::iron::math::RayCaster_obj::loc);
HXLINE( 124)			float uCoord = u->dot(hit);
HXLINE( 125)			float vCoord = v->dot(hit);
HXLINE( 127)			 ::iron::math::Vec4 dim = obj->transform->dim;
HXLINE( 128)			Float hx = ((Float)dim->x / (Float)(int)2);
HXLINE( 130)			Float hy;
HXDLIN( 130)			if ((dim->z > dim->y)) {
HXLINE( 130)				hy = ((Float)dim->z / (Float)(int)2);
            			}
            			else {
HXLINE( 130)				hy = ((Float)dim->y / (Float)(int)2);
            			}
HXLINE( 133)			Float ix = (((((Float)uCoord / (Float)hx) * (int)-1) * ((Float)0.5)) + ((Float)0.5));
HXLINE( 134)			Float iy = ((((Float)vCoord / (Float)hy) * ((Float)0.5)) + ((Float)0.5));
HXLINE( 136)			return  ::iron::math::Vec2_obj::__alloc( HX_CTX ,ix,iy);
            		}
HXLINE( 138)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(RayCaster_obj,getPlaneUV,return )


RayCaster_obj::RayCaster_obj()
{
}

bool RayCaster_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"m") ) { outValue = ( m ); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"loc") ) { outValue = ( loc ); return true; }
		if (HX_FIELD_EQ(inName,"nor") ) { outValue = ( nor ); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"PInv") ) { outValue = ( PInv ); return true; }
		if (HX_FIELD_EQ(inName,"VInv") ) { outValue = ( VInv ); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"VPInv") ) { outValue = ( VPInv ); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"getRay") ) { outValue = getRay_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"getPlaneUV") ) { outValue = getPlaneUV_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"getDirection") ) { outValue = getDirection_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"boxIntersect") ) { outValue = boxIntersect_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"planeIntersect") ) { outValue = planeIntersect_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"closestBoxIntersect") ) { outValue = closestBoxIntersect_dyn(); return true; }
	}
	return false;
}

bool RayCaster_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"m") ) { m=ioValue.Cast<  ::iron::math::Mat4 >(); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"loc") ) { loc=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		if (HX_FIELD_EQ(inName,"nor") ) { nor=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"PInv") ) { PInv=ioValue.Cast<  ::iron::math::Mat4 >(); return true; }
		if (HX_FIELD_EQ(inName,"VInv") ) { VInv=ioValue.Cast<  ::iron::math::Mat4 >(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"VPInv") ) { VPInv=ioValue.Cast<  ::iron::math::Mat4 >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *RayCaster_obj_sMemberStorageInfo = 0;
static hx::StaticInfo RayCaster_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::iron::math::Mat4*/ ,(void *) &RayCaster_obj::VPInv,HX_HCSTRING("VPInv","\xd7","\xb9","\x8e","\xb9")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(void *) &RayCaster_obj::PInv,HX_HCSTRING("PInv","\x81","\xd6","\x18","\x35")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(void *) &RayCaster_obj::VInv,HX_HCSTRING("VInv","\x3b","\x1e","\x10","\x39")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &RayCaster_obj::loc,HX_HCSTRING("loc","\x80","\x54","\x52","\x00")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &RayCaster_obj::nor,HX_HCSTRING("nor","\x11","\xd9","\x53","\x00")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(void *) &RayCaster_obj::m,HX_HCSTRING("m","\x6d","\x00","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void RayCaster_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(RayCaster_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(RayCaster_obj::VPInv,"VPInv");
	HX_MARK_MEMBER_NAME(RayCaster_obj::PInv,"PInv");
	HX_MARK_MEMBER_NAME(RayCaster_obj::VInv,"VInv");
	HX_MARK_MEMBER_NAME(RayCaster_obj::loc,"loc");
	HX_MARK_MEMBER_NAME(RayCaster_obj::nor,"nor");
	HX_MARK_MEMBER_NAME(RayCaster_obj::m,"m");
};

#ifdef HXCPP_VISIT_ALLOCS
static void RayCaster_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(RayCaster_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::VPInv,"VPInv");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::PInv,"PInv");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::VInv,"VInv");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::loc,"loc");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::nor,"nor");
	HX_VISIT_MEMBER_NAME(RayCaster_obj::m,"m");
};

#endif

hx::Class RayCaster_obj::__mClass;

static ::String RayCaster_obj_sStaticFields[] = {
	HX_HCSTRING("getRay","\xf4","\x0e","\x26","\xa3"),
	HX_HCSTRING("VPInv","\xd7","\xb9","\x8e","\xb9"),
	HX_HCSTRING("PInv","\x81","\xd6","\x18","\x35"),
	HX_HCSTRING("VInv","\x3b","\x1e","\x10","\x39"),
	HX_HCSTRING("getDirection","\xc9","\xfe","\x96","\x1f"),
	HX_HCSTRING("boxIntersect","\x54","\x89","\xe8","\x12"),
	HX_HCSTRING("closestBoxIntersect","\x4d","\x51","\xe8","\xa9"),
	HX_HCSTRING("planeIntersect","\xe3","\x36","\xcd","\xa3"),
	HX_HCSTRING("loc","\x80","\x54","\x52","\x00"),
	HX_HCSTRING("nor","\x11","\xd9","\x53","\x00"),
	HX_HCSTRING("m","\x6d","\x00","\x00","\x00"),
	HX_HCSTRING("getPlaneUV","\xc7","\x1d","\x31","\xd2"),
	::String(null())
};

void RayCaster_obj::__register()
{
	hx::Object *dummy = new RayCaster_obj;
	RayCaster_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("iron.math.RayCaster","\x96","\x4c","\xee","\x3f");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &RayCaster_obj::__GetStatic;
	__mClass->mSetStaticField = &RayCaster_obj::__SetStatic;
	__mClass->mMarkFunc = RayCaster_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(RayCaster_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< RayCaster_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = RayCaster_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = RayCaster_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = RayCaster_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void RayCaster_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_26_boot)
HXDLIN(  26)		VPInv = ::iron::math::Mat4_obj::identity();
            	}
{
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_27_boot)
HXDLIN(  27)		PInv = ::iron::math::Mat4_obj::identity();
            	}
{
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_28_boot)
HXDLIN(  28)		VInv = ::iron::math::Mat4_obj::identity();
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_91_boot)
HXDLIN(  91)		loc =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_ddaf8f915c13665f_92_boot)
HXDLIN(  92)		nor =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_STACKFRAME(&_hx_pos_ddaf8f915c13665f_93_boot)
HXDLIN(  93)		m = ::iron::math::Mat4_obj::identity();
            	}
}

} // end namespace iron
} // end namespace math
