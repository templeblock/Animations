// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Quat
#include <iron/math/Quat.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <iron/math/Vec4.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix4
#include <kha/math/FastMatrix4.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_b22ee3d0836f1999_19_new,"iron.math.Quat","new",0x0bb86329,"iron.math.Quat.new","iron/math/Quat.hx",19,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_26_set,"iron.math.Quat","set",0x0bbc2e6b,"iron.math.Quat.set","iron/math/Quat.hx",26,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_33_fromAxisAngle,"iron.math.Quat","fromAxisAngle",0xa8a0b4b1,"iron.math.Quat.fromAxisAngle","iron/math/Quat.hx",33,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_42_toAxisAngle,"iron.math.Quat","toAxisAngle",0x403da640,"iron.math.Quat.toAxisAngle","iron/math/Quat.hx",42,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_59_fromRotationMat,"iron.math.Quat","fromRotationMat",0x56297301,"iron.math.Quat.fromRotationMat","iron/math/Quat.hx",59,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_100_mult,"iron.math.Quat","mult",0x35014507,"iron.math.Quat.mult","iron/math/Quat.hx",100,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_103_multquats,"iron.math.Quat","multquats",0xd1aba555,"iron.math.Quat.multquats","iron/math/Quat.hx",103,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_114_normalize,"iron.math.Quat","normalize",0x3e198716,"iron.math.Quat.normalize","iron/math/Quat.hx",114,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_131_setFrom,"iron.math.Quat","setFrom",0xd2e71175,"iron.math.Quat.setFrom","iron/math/Quat.hx",131,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_138_getEuler,"iron.math.Quat","getEuler",0x777d9d8a,"iron.math.Quat.getEuler","iron/math/Quat.hx",138,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_166_fromEuler,"iron.math.Quat","fromEuler",0xbc221328,"iron.math.Quat.fromEuler","iron/math/Quat.hx",166,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_181_toMat,"iron.math.Quat","toMat",0x2fda52ee,"iron.math.Quat.toMat","iron/math/Quat.hx",181,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_250_dot,"iron.math.Quat","dot",0x0bb0d552,"iron.math.Quat.dot","iron/math/Quat.hx",250,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_253_fromTo,"iron.math.Quat","fromTo",0xe6e52e5c,"iron.math.Quat.fromTo","iron/math/Quat.hx",253,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_274_toString,"iron.math.Quat","toString",0xdaf48543,"iron.math.Quat.toString","iron/math/Quat.hx",274,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_16_identity,"iron.math.Quat","identity",0x5bb4f9d5,"iron.math.Quat.identity","iron/math/Quat.hx",16,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_205_lerp,"iron.math.Quat","lerp",0x344bef8e,"iron.math.Quat.lerp","iron/math/Quat.hx",205,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_224_slerp,"iron.math.Quat","slerp",0x9a8a5f73,"iron.math.Quat.slerp","iron/math/Quat.hx",224,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_12_boot,"iron.math.Quat","boot",0x2db76149,"iron.math.Quat.boot","iron/math/Quat.hx",12,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_13_boot,"iron.math.Quat","boot",0x2db76149,"iron.math.Quat.boot","iron/math/Quat.hx",13,0xb4f4e407)
HX_LOCAL_STACK_FRAME(_hx_pos_b22ee3d0836f1999_14_boot,"iron.math.Quat","boot",0x2db76149,"iron.math.Quat.boot","iron/math/Quat.hx",14,0xb4f4e407)
namespace iron{
namespace math{

void Quat_obj::__construct(hx::Null< Float >  __o_x,hx::Null< Float >  __o_y,hx::Null< Float >  __o_z,hx::Null< Float >  __o_w){
Float x = __o_x.Default(((Float)0.0));
Float y = __o_y.Default(((Float)0.0));
Float z = __o_z.Default(((Float)0.0));
Float w = __o_w.Default(((Float)1.0));
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_19_new)
HXLINE(  20)		this->x = x;
HXLINE(  21)		this->y = y;
HXLINE(  22)		this->z = z;
HXLINE(  23)		this->w = w;
            	}

Dynamic Quat_obj::__CreateEmpty() { return new Quat_obj; }

void *Quat_obj::_hx_vtable = 0;

Dynamic Quat_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Quat_obj > _hx_result = new Quat_obj();
	_hx_result->__construct(inArgs[0],inArgs[1],inArgs[2],inArgs[3]);
	return _hx_result;
}

bool Quat_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1441ffeb;
}

void Quat_obj::set(float x,float y,float z,float w){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_26_set)
HXLINE(  27)		this->x = x;
HXLINE(  28)		this->y = y;
HXLINE(  29)		this->z = z;
HXLINE(  30)		this->w = w;
            	}


HX_DEFINE_DYNAMIC_FUNC4(Quat_obj,set,(void))

void Quat_obj::fromAxisAngle( ::iron::math::Vec4 axis,float angle){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_33_fromAxisAngle)
HXLINE(  34)		float s = ::Math_obj::sin((angle * ((Float)0.5)));
HXLINE(  35)		this->x = (axis->x * s);
HXLINE(  36)		this->y = (axis->y * s);
HXLINE(  37)		this->z = (axis->z * s);
HXLINE(  38)		this->w = ::Math_obj::cos((angle * ((Float)0.5)));
HXLINE(  39)		this->normalize();
            	}


HX_DEFINE_DYNAMIC_FUNC2(Quat_obj,fromAxisAngle,(void))

float Quat_obj::toAxisAngle( ::iron::math::Vec4 axis){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_42_toAxisAngle)
HXLINE(  43)		this->normalize();
HXLINE(  44)		Float angle = ((int)2 * ::Math_obj::acos(this->w));
HXLINE(  45)		Float s = ::Math_obj::sqrt(((int)1 - (this->w * this->w)));
HXLINE(  46)		if ((s < ((Float)0.001))) {
HXLINE(  47)			axis->x = this->x;
HXLINE(  48)			axis->y = this->y;
HXLINE(  49)			axis->z = this->z;
            		}
            		else {
HXLINE(  52)			axis->x = ((Float)this->x / (Float)s);
HXLINE(  53)			axis->y = ((Float)this->y / (Float)s);
HXLINE(  54)			axis->z = ((Float)this->z / (Float)s);
            		}
HXLINE(  56)		return angle;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,toAxisAngle,return )

 ::iron::math::Quat Quat_obj::fromRotationMat( ::iron::math::Mat4 m){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_59_fromRotationMat)
HXLINE(  61)		float m11 = m->self->_00;
HXDLIN(  61)		float m12 = m->self->_10;
HXDLIN(  61)		float m13 = m->self->_20;
HXLINE(  62)		float m21 = m->self->_01;
HXDLIN(  62)		float m22 = m->self->_11;
HXDLIN(  62)		float m23 = m->self->_21;
HXLINE(  63)		float m31 = m->self->_02;
HXDLIN(  63)		float m32 = m->self->_12;
HXDLIN(  63)		float m33 = m->self->_22;
HXLINE(  65)		float tr = ((m11 + m22) + m33);
HXLINE(  66)		Float s = ((Float)0.0);
HXLINE(  68)		if ((tr > (int)0)) {
HXLINE(  69)			s = ((Float)((Float)0.5) / (Float)::Math_obj::sqrt((tr + ((Float)1.0))));
HXLINE(  70)			this->w = ((Float)((Float)0.25) / (Float)s);
HXLINE(  71)			this->x = ((m32 - m23) * s);
HXLINE(  72)			this->y = ((m13 - m31) * s);
HXLINE(  73)			this->z = ((m21 - m12) * s);
            		}
            		else {
HXLINE(  75)			bool _hx_tmp;
HXDLIN(  75)			if ((m11 > m22)) {
HXLINE(  75)				_hx_tmp = (m11 > m33);
            			}
            			else {
HXLINE(  75)				_hx_tmp = false;
            			}
HXDLIN(  75)			if (_hx_tmp) {
HXLINE(  76)				s = (((Float)2.0) * ::Math_obj::sqrt((((((Float)1.0) + m11) - m22) - m33)));
HXLINE(  77)				this->w = ((Float)(m32 - m23) / (Float)s);
HXLINE(  78)				this->x = (((Float)0.25) * s);
HXLINE(  79)				this->y = ((Float)(m12 + m21) / (Float)s);
HXLINE(  80)				this->z = ((Float)(m13 + m31) / (Float)s);
            			}
            			else {
HXLINE(  82)				if ((m22 > m33)) {
HXLINE(  83)					s = (((Float)2.0) * ::Math_obj::sqrt((((((Float)1.0) + m22) - m11) - m33)));
HXLINE(  84)					this->w = ((Float)(m13 - m31) / (Float)s);
HXLINE(  85)					this->x = ((Float)(m12 + m21) / (Float)s);
HXLINE(  86)					this->y = (((Float)0.25) * s);
HXLINE(  87)					this->z = ((Float)(m23 + m32) / (Float)s);
            				}
            				else {
HXLINE(  90)					s = (((Float)2.0) * ::Math_obj::sqrt((((((Float)1.0) + m33) - m11) - m22)));
HXLINE(  91)					this->w = ((Float)(m21 - m12) / (Float)s);
HXLINE(  92)					this->x = ((Float)(m13 + m31) / (Float)s);
HXLINE(  93)					this->y = ((Float)(m23 + m32) / (Float)s);
HXLINE(  94)					this->z = (((Float)0.25) * s);
            				}
            			}
            		}
HXLINE(  96)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,fromRotationMat,return )

void Quat_obj::mult( ::iron::math::Quat q){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_100_mult)
HXDLIN( 100)		this->multquats(hx::ObjectPtr<OBJ_>(this),q);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,mult,(void))

void Quat_obj::multquats( ::iron::math::Quat q1, ::iron::math::Quat q2){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_103_multquats)
HXLINE( 104)		float x2 = (q1->x * q2->w);
HXDLIN( 104)		float x21 = (x2 + (q1->w * q2->x));
HXDLIN( 104)		float x22 = (x21 + (q1->y * q2->z));
HXDLIN( 104)		float x23 = (x22 - (q1->z * q2->y));
HXLINE( 105)		float y2 = (q1->w * q2->y);
HXDLIN( 105)		float y21 = (y2 - (q1->x * q2->z));
HXDLIN( 105)		float y22 = (y21 + (q1->y * q2->w));
HXDLIN( 105)		float y23 = (y22 + (q1->z * q2->x));
HXLINE( 106)		float z2 = (q1->w * q2->z);
HXDLIN( 106)		float z21 = (z2 + (q1->x * q2->y));
HXDLIN( 106)		float z22 = (z21 - (q1->y * q2->x));
HXDLIN( 106)		float z23 = (z22 + (q1->z * q2->w));
HXLINE( 107)		float w2 = (q1->w * q2->w);
HXDLIN( 107)		float w21 = (w2 - (q1->x * q2->x));
HXDLIN( 107)		float w22 = (w21 - (q1->y * q2->y));
HXDLIN( 107)		float w23 = (w22 - (q1->z * q2->z));
HXLINE( 108)		this->x = x23;
HXLINE( 109)		this->y = y23;
HXLINE( 110)		this->z = z23;
HXLINE( 111)		this->w = w23;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Quat_obj,multquats,(void))

void Quat_obj::normalize(){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_114_normalize)
HXLINE( 115)		float v = (this->x * this->x);
HXDLIN( 115)		float v1 = (v + (this->y * this->y));
HXDLIN( 115)		float v2 = (v1 + (this->z * this->z));
HXDLIN( 115)		Float l = ::Math_obj::sqrt((v2 + (this->w * this->w)));
HXLINE( 116)		if ((l == ((Float)0.0))) {
HXLINE( 117)			this->x = (int)0;
HXLINE( 118)			this->y = (int)0;
HXLINE( 119)			this->z = (int)0;
HXLINE( 120)			this->w = (int)0;
            		}
            		else {
HXLINE( 123)			l = ((Float)((Float)1.0) / (Float)l);
HXLINE( 124)			 ::iron::math::Quat _hx_tmp = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 124)			_hx_tmp->x = (_hx_tmp->x * l);
HXLINE( 125)			 ::iron::math::Quat _hx_tmp1 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 125)			_hx_tmp1->y = (_hx_tmp1->y * l);
HXLINE( 126)			 ::iron::math::Quat _hx_tmp2 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 126)			_hx_tmp2->z = (_hx_tmp2->z * l);
HXLINE( 127)			 ::iron::math::Quat _hx_tmp3 = hx::ObjectPtr<OBJ_>(this);
HXDLIN( 127)			_hx_tmp3->w = (_hx_tmp3->w * l);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Quat_obj,normalize,(void))

void Quat_obj::setFrom( ::iron::math::Quat q){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_131_setFrom)
HXLINE( 132)		this->x = q->x;
HXLINE( 133)		this->y = q->y;
HXLINE( 134)		this->z = q->z;
HXLINE( 135)		this->w = q->w;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,setFrom,(void))

 ::iron::math::Vec4 Quat_obj::getEuler(){
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_138_getEuler)
HXLINE( 140)		Float roll = ::Math_obj::NaN;
HXLINE( 141)		Float yaw = ((Float)0.0);
HXLINE( 142)		Float pitch = ((Float)0.0);
HXLINE( 144)		float test = (this->x * this->y);
HXDLIN( 144)		float test1 = (test + (this->z * this->w));
HXLINE( 145)		if ((test1 > ((Float)0.499))) {
HXLINE( 146)			roll = ((int)2 * ::Math_obj::atan2(this->x,this->w));
HXLINE( 147)			yaw = ((Float)1.57079632679489656);
HXLINE( 148)			pitch = (int)0;
            		}
HXLINE( 150)		if ((test1 < ((Float)-0.499))) {
HXLINE( 151)			roll = ((int)-2 * ::Math_obj::atan2(this->x,this->w));
HXLINE( 152)			yaw = ((Float)-1.57079632679489656);
HXLINE( 153)			pitch = (int)0;
            		}
HXLINE( 155)		if (::Math_obj::isNaN(roll)) {
HXLINE( 156)			float sqx = (this->x * this->x);
HXLINE( 157)			float sqy = (this->y * this->y);
HXLINE( 158)			float sqz = (this->z * this->z);
HXLINE( 159)			float y = (((int)2 * this->y) * this->w);
HXDLIN( 159)			roll = ::Math_obj::atan2((y - (((int)2 * this->x) * this->z)),((((Float)1.0) - ((int)2 * sqy)) - ((int)2 * sqz)));
HXLINE( 160)			yaw = ::Math_obj::asin(((int)2 * test1));
HXLINE( 161)			float y1 = (((int)2 * this->x) * this->w);
HXDLIN( 161)			pitch = ::Math_obj::atan2((y1 - (((int)2 * this->y) * this->z)),((((Float)1.0) - ((int)2 * sqx)) - ((int)2 * sqz)));
            		}
HXLINE( 163)		return  ::iron::math::Vec4_obj::__alloc( HX_CTX ,pitch,roll,yaw,null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Quat_obj,getEuler,return )

 ::iron::math::Quat Quat_obj::fromEuler(float x,float y,float z){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_166_fromEuler)
HXLINE( 167)		Float c1 = ::Math_obj::cos(((Float)x / (Float)(int)2));
HXLINE( 168)		Float c2 = ::Math_obj::cos(((Float)y / (Float)(int)2));
HXLINE( 169)		Float c3 = ::Math_obj::cos(((Float)z / (Float)(int)2));
HXLINE( 170)		Float s1 = ::Math_obj::sin(((Float)x / (Float)(int)2));
HXLINE( 171)		Float s2 = ::Math_obj::sin(((Float)y / (Float)(int)2));
HXLINE( 172)		Float s3 = ::Math_obj::sin(((Float)z / (Float)(int)2));
HXLINE( 174)		this->x = (((s1 * c2) * c3) + ((c1 * s2) * s3));
HXLINE( 175)		this->y = (((c1 * s2) * c3) + ((s1 * c2) * s3));
HXLINE( 176)		this->z = (((c1 * c2) * s3) - ((s1 * s2) * c3));
HXLINE( 177)		this->w = (((c1 * c2) * c3) - ((s1 * s2) * s3));
HXLINE( 178)		return hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC3(Quat_obj,fromEuler,return )

 ::iron::math::Mat4 Quat_obj::toMat( ::iron::math::Mat4 m){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_181_toMat)
HXLINE( 182)		float x2 = (this->x + this->x);
HXDLIN( 182)		float y2 = (this->y + this->y);
HXDLIN( 182)		float z2 = (this->z + this->z);
HXLINE( 183)		float xx = (this->x * x2);
HXDLIN( 183)		float xy = (this->x * y2);
HXDLIN( 183)		float xz = (this->x * z2);
HXLINE( 184)		float yy = (this->y * y2);
HXDLIN( 184)		float yz = (this->y * z2);
HXDLIN( 184)		float zz = (this->z * z2);
HXLINE( 185)		float wx = (this->w * x2);
HXDLIN( 185)		float wy = (this->w * y2);
HXDLIN( 185)		float wz = (this->w * z2);
HXLINE( 187)		m->self->_00 = ((int)1 - (yy + zz));
HXLINE( 188)		m->self->_10 = (xy - wz);
HXLINE( 189)		m->self->_20 = (xz + wy);
HXLINE( 191)		m->self->_01 = (xy + wz);
HXLINE( 192)		m->self->_11 = ((int)1 - (xx + zz));
HXLINE( 193)		m->self->_21 = (yz - wx);
HXLINE( 195)		m->self->_02 = (xz - wy);
HXLINE( 196)		m->self->_12 = (yz + wx);
HXLINE( 197)		m->self->_22 = ((int)1 - (xx + yy));
HXLINE( 199)		m->self->_03 = (int)0;
HXDLIN( 199)		m->self->_13 = (int)0;
HXDLIN( 199)		m->self->_23 = (int)0;
HXLINE( 200)		m->self->_30 = (int)0;
HXDLIN( 200)		m->self->_31 = (int)0;
HXDLIN( 200)		m->self->_32 = (int)0;
HXDLIN( 200)		m->self->_33 = (int)1;
HXLINE( 202)		return m;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,toMat,return )

float Quat_obj::dot( ::iron::math::Quat q){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_250_dot)
HXDLIN( 250)		float _hx_tmp = (this->x * q->x);
HXDLIN( 250)		float _hx_tmp1 = (_hx_tmp + (this->y * q->y));
HXDLIN( 250)		float _hx_tmp2 = (_hx_tmp1 + (this->z * q->z));
HXDLIN( 250)		return (_hx_tmp2 + (this->w * q->w));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Quat_obj,dot,return )

void Quat_obj::fromTo( ::iron::math::Vec4 v1, ::iron::math::Vec4 v2){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_253_fromTo)
HXLINE( 255)		 ::iron::math::Vec4 a = ::iron::math::Quat_obj::helpVec0;
HXLINE( 256)		float dot = v1->dot(v2);
HXLINE( 257)		if ((dot < ((Float)-0.999999))) {
HXLINE( 258)			a->crossvecs(::iron::math::Vec4_obj::xAxis(),v1);
HXLINE( 259)			float v = (a->x * a->x);
HXDLIN( 259)			float v3 = (v + (a->y * a->y));
HXDLIN( 259)			if ((::Math_obj::sqrt((v3 + (a->z * a->z))) < ((Float)0.000001))) {
HXLINE( 259)				a->crossvecs(::iron::math::Vec4_obj::yAxis(),v1);
            			}
HXLINE( 260)			a->normalize();
HXLINE( 261)			this->fromAxisAngle(a,((Float)3.14159265358979323846));
            		}
            		else {
HXLINE( 263)			if ((dot > ((Float)0.999999))) {
HXLINE( 264)				this->x = (int)0;
HXDLIN( 264)				this->y = (int)0;
HXDLIN( 264)				this->z = (int)0;
HXDLIN( 264)				this->w = (int)1;
            			}
            			else {
HXLINE( 267)				a->crossvecs(v1,v2);
HXLINE( 268)				{
HXLINE( 268)					this->x = a->x;
HXDLIN( 268)					this->y = a->y;
HXDLIN( 268)					this->z = a->z;
HXDLIN( 268)					this->w = ((int)1 + dot);
            				}
HXLINE( 269)				this->normalize();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC2(Quat_obj,fromTo,(void))

::String Quat_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_b22ee3d0836f1999_274_toString)
HXDLIN( 274)		::String _hx_tmp = (::Std_obj::string(this->x) + HX_(", ",74,26,00,00));
HXDLIN( 274)		::String _hx_tmp1 = ((_hx_tmp + ::Std_obj::string(this->y)) + HX_(", ",74,26,00,00));
HXDLIN( 274)		::String _hx_tmp2 = ((_hx_tmp1 + ::Std_obj::string(this->z)) + HX_(", ",74,26,00,00));
HXDLIN( 274)		return (_hx_tmp2 + ::Std_obj::string(this->w));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Quat_obj,toString,return )

 ::iron::math::Vec4 Quat_obj::helpVec0;

 ::iron::math::Vec4 Quat_obj::helpVec1;

 ::iron::math::Vec4 Quat_obj::helpVec2;

 ::iron::math::Quat Quat_obj::identity(){
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_16_identity)
HXDLIN(  16)		return  ::iron::math::Quat_obj::__alloc( HX_CTX ,((Float)0.0),((Float)0.0),((Float)0.0),((Float)1.0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Quat_obj,identity,return )

 ::iron::math::Quat Quat_obj::lerp( ::iron::math::Quat q1, ::iron::math::Quat q2,float ratio){
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_205_lerp)
HXLINE( 206)		 ::iron::math::Quat c =  ::iron::math::Quat_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 207)		 ::iron::math::Quat ca =  ::iron::math::Quat_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 208)		ca->setFrom(q1);
HXLINE( 209)		float dot = q1->dot(q2);
HXLINE( 210)		if ((dot < ((Float)0.0))) {
HXLINE( 211)			ca->w = -(ca->w);
HXLINE( 212)			ca->x = -(ca->x);
HXLINE( 213)			ca->y = -(ca->y);
HXLINE( 214)			ca->z = -(ca->z);
            		}
HXLINE( 216)		float ca1 = ca->x;
HXDLIN( 216)		c->x = (ca1 + ((q2->x - ca->x) * ratio));
HXLINE( 217)		float ca2 = ca->y;
HXDLIN( 217)		c->y = (ca2 + ((q2->y - ca->y) * ratio));
HXLINE( 218)		float ca3 = ca->z;
HXDLIN( 218)		c->z = (ca3 + ((q2->z - ca->z) * ratio));
HXLINE( 219)		float ca4 = ca->w;
HXDLIN( 219)		c->w = (ca4 + ((q2->w - ca->w) * ratio));
HXLINE( 220)		c->normalize();
HXLINE( 221)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Quat_obj,lerp,return )

 ::iron::math::Quat Quat_obj::slerp( ::iron::math::Quat q1, ::iron::math::Quat q2,float v){
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_224_slerp)
HXLINE( 226)		 ::iron::math::Quat c =  ::iron::math::Quat_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 227)		float cosHalfTheta = q1->dot(q2);
HXLINE( 228)		if ((::Math_obj::abs(cosHalfTheta) >= (int)1)) {
HXLINE( 229)			c->x = q1->x;
HXLINE( 230)			c->y = q1->y;
HXLINE( 231)			c->z = q1->z;
HXLINE( 232)			c->w = q1->w;
HXLINE( 233)			return c;
            		}
HXLINE( 235)		Float halfTheta = ::Math_obj::acos(cosHalfTheta);
HXLINE( 236)		Float invSinHalfTheta = ((Float)(int)1 / (Float)::Math_obj::sqrt(((int)1 - (cosHalfTheta * cosHalfTheta))));
HXLINE( 237)		if ((::Math_obj::abs(invSinHalfTheta) > ((Float)1e3))) {
HXLINE( 238)			return ::iron::math::Quat_obj::lerp(q1,q2,((Float)0.5));
            		}
HXLINE( 240)		Float a = (::Math_obj::sin((((int)1 - v) * halfTheta)) * invSinHalfTheta);
HXLINE( 241)		int b;
HXDLIN( 241)		if ((cosHalfTheta < (int)0)) {
HXLINE( 241)			b = (int)-1;
            		}
            		else {
HXLINE( 241)			b = (int)1;
            		}
HXDLIN( 241)		Float b1 = ((::Math_obj::sin((v * halfTheta)) * invSinHalfTheta) * b);
HXLINE( 242)		Float _hx_tmp = (q1->x * a);
HXDLIN( 242)		c->x = (_hx_tmp + (q2->x * b1));
HXLINE( 243)		Float _hx_tmp1 = (q1->y * a);
HXDLIN( 243)		c->y = (_hx_tmp1 + (q2->y * b1));
HXLINE( 244)		Float _hx_tmp2 = (q1->z * a);
HXDLIN( 244)		c->z = (_hx_tmp2 + (q2->z * b1));
HXLINE( 245)		Float _hx_tmp3 = (q1->w * a);
HXDLIN( 245)		c->w = (_hx_tmp3 + (q2->w * b1));
HXLINE( 246)		return c;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Quat_obj,slerp,return )


hx::ObjectPtr< Quat_obj > Quat_obj::__new(hx::Null< Float >  __o_x,hx::Null< Float >  __o_y,hx::Null< Float >  __o_z,hx::Null< Float >  __o_w) {
	hx::ObjectPtr< Quat_obj > __this = new Quat_obj();
	__this->__construct(__o_x,__o_y,__o_z,__o_w);
	return __this;
}

hx::ObjectPtr< Quat_obj > Quat_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< Float >  __o_x,hx::Null< Float >  __o_y,hx::Null< Float >  __o_z,hx::Null< Float >  __o_w) {
	Quat_obj *__this = (Quat_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Quat_obj), false, "iron.math.Quat"));
	*(void **)__this = Quat_obj::_hx_vtable;
	__this->__construct(__o_x,__o_y,__o_z,__o_w);
	return __this;
}

Quat_obj::Quat_obj()
{
}

hx::Val Quat_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { return hx::Val( x ); }
		if (HX_FIELD_EQ(inName,"y") ) { return hx::Val( y ); }
		if (HX_FIELD_EQ(inName,"z") ) { return hx::Val( z ); }
		if (HX_FIELD_EQ(inName,"w") ) { return hx::Val( w ); }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"set") ) { return hx::Val( set_dyn() ); }
		if (HX_FIELD_EQ(inName,"dot") ) { return hx::Val( dot_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"mult") ) { return hx::Val( mult_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"toMat") ) { return hx::Val( toMat_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"fromTo") ) { return hx::Val( fromTo_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"setFrom") ) { return hx::Val( setFrom_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"getEuler") ) { return hx::Val( getEuler_dyn() ); }
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"multquats") ) { return hx::Val( multquats_dyn() ); }
		if (HX_FIELD_EQ(inName,"normalize") ) { return hx::Val( normalize_dyn() ); }
		if (HX_FIELD_EQ(inName,"fromEuler") ) { return hx::Val( fromEuler_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"toAxisAngle") ) { return hx::Val( toAxisAngle_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fromAxisAngle") ) { return hx::Val( fromAxisAngle_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"fromRotationMat") ) { return hx::Val( fromRotationMat_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Quat_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"lerp") ) { outValue = lerp_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"slerp") ) { outValue = slerp_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"helpVec0") ) { outValue = ( helpVec0 ); return true; }
		if (HX_FIELD_EQ(inName,"helpVec1") ) { outValue = ( helpVec1 ); return true; }
		if (HX_FIELD_EQ(inName,"helpVec2") ) { outValue = ( helpVec2 ); return true; }
		if (HX_FIELD_EQ(inName,"identity") ) { outValue = identity_dyn(); return true; }
	}
	return false;
}

hx::Val Quat_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"x") ) { x=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"y") ) { y=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"z") ) { z=inValue.Cast< float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"w") ) { w=inValue.Cast< float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Quat_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 8:
		if (HX_FIELD_EQ(inName,"helpVec0") ) { helpVec0=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		if (HX_FIELD_EQ(inName,"helpVec1") ) { helpVec1=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		if (HX_FIELD_EQ(inName,"helpVec2") ) { helpVec2=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
	}
	return false;
}

void Quat_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("x","\x78","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("y","\x79","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("z","\x7a","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("w","\x77","\x00","\x00","\x00"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Quat_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::cpp::Float32*/ ,(int)offsetof(Quat_obj,x),HX_HCSTRING("x","\x78","\x00","\x00","\x00")},
	{hx::fsObject /*::cpp::Float32*/ ,(int)offsetof(Quat_obj,y),HX_HCSTRING("y","\x79","\x00","\x00","\x00")},
	{hx::fsObject /*::cpp::Float32*/ ,(int)offsetof(Quat_obj,z),HX_HCSTRING("z","\x7a","\x00","\x00","\x00")},
	{hx::fsObject /*::cpp::Float32*/ ,(int)offsetof(Quat_obj,w),HX_HCSTRING("w","\x77","\x00","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo Quat_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &Quat_obj::helpVec0,HX_HCSTRING("helpVec0","\xbd","\x7a","\x07","\x89")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &Quat_obj::helpVec1,HX_HCSTRING("helpVec1","\xbe","\x7a","\x07","\x89")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &Quat_obj::helpVec2,HX_HCSTRING("helpVec2","\xbf","\x7a","\x07","\x89")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String Quat_obj_sMemberFields[] = {
	HX_HCSTRING("x","\x78","\x00","\x00","\x00"),
	HX_HCSTRING("y","\x79","\x00","\x00","\x00"),
	HX_HCSTRING("z","\x7a","\x00","\x00","\x00"),
	HX_HCSTRING("w","\x77","\x00","\x00","\x00"),
	HX_HCSTRING("set","\xa2","\x9b","\x57","\x00"),
	HX_HCSTRING("fromAxisAngle","\xa8","\x6c","\x6f","\xf0"),
	HX_HCSTRING("toAxisAngle","\x77","\xa2","\x6b","\xe3"),
	HX_HCSTRING("fromRotationMat","\xb8","\x56","\x0f","\x39"),
	HX_HCSTRING("mult","\xf0","\x67","\x65","\x48"),
	HX_HCSTRING("multquats","\xcc","\x55","\x33","\x3f"),
	HX_HCSTRING("normalize","\x8d","\x37","\xa1","\xab"),
	HX_HCSTRING("setFrom","\x2c","\xe6","\x46","\x09"),
	HX_HCSTRING("getEuler","\xf3","\xe8","\xf7","\xd4"),
	HX_HCSTRING("fromEuler","\x9f","\xc3","\xa9","\x29"),
	HX_HCSTRING("toMat","\xe5","\xbb","\x14","\x14"),
	HX_HCSTRING("dot","\x89","\x42","\x4c","\x00"),
	HX_HCSTRING("fromTo","\x85","\x9d","\xc6","\xb5"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	::String(null()) };

static void Quat_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Quat_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Quat_obj::helpVec0,"helpVec0");
	HX_MARK_MEMBER_NAME(Quat_obj::helpVec1,"helpVec1");
	HX_MARK_MEMBER_NAME(Quat_obj::helpVec2,"helpVec2");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Quat_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Quat_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Quat_obj::helpVec0,"helpVec0");
	HX_VISIT_MEMBER_NAME(Quat_obj::helpVec1,"helpVec1");
	HX_VISIT_MEMBER_NAME(Quat_obj::helpVec2,"helpVec2");
};

#endif

hx::Class Quat_obj::__mClass;

static ::String Quat_obj_sStaticFields[] = {
	HX_HCSTRING("helpVec0","\xbd","\x7a","\x07","\x89"),
	HX_HCSTRING("helpVec1","\xbe","\x7a","\x07","\x89"),
	HX_HCSTRING("helpVec2","\xbf","\x7a","\x07","\x89"),
	HX_HCSTRING("identity","\x3e","\x45","\x2f","\xb9"),
	HX_HCSTRING("lerp","\x77","\x12","\xb0","\x47"),
	HX_HCSTRING("slerp","\x6a","\xc8","\xc4","\x7e"),
	::String(null())
};

void Quat_obj::__register()
{
	hx::Object *dummy = new Quat_obj;
	Quat_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("iron.math.Quat","\xb7","\x9a","\xd3","\xf3");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Quat_obj::__GetStatic;
	__mClass->mSetStaticField = &Quat_obj::__SetStatic;
	__mClass->mMarkFunc = Quat_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Quat_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Quat_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Quat_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Quat_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Quat_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Quat_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Quat_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_12_boot)
HXDLIN(  12)		helpVec0 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_13_boot)
HXDLIN(  13)		helpVec1 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_b22ee3d0836f1999_14_boot)
HXDLIN(  14)		helpVec2 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
}

} // end namespace iron
} // end namespace math
