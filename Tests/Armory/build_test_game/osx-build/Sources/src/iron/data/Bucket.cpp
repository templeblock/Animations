// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_7d028c26efabce49
#define INCLUDED_7d028c26efabce49
#include "cpp_uint32array.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_iron_data_Bucket
#include <iron/data/Bucket.h>
#endif
#ifndef INCLUDED_iron_data_Data
#include <iron/data/Data.h>
#endif
#ifndef INCLUDED_iron_data_Geometry
#include <iron/data/Geometry.h>
#endif
#ifndef INCLUDED_iron_data_MeshData
#include <iron/data/MeshData.h>
#endif
#ifndef INCLUDED_iron_data_ShaderData
#include <iron/data/ShaderData.h>
#endif
#ifndef INCLUDED_iron_object_MeshObject
#include <iron/object/MeshObject.h>
#endif
#ifndef INCLUDED_iron_object_Object
#include <iron/object/Object.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_arrays_Uint32ArrayPrivate
#include <kha/arrays/Uint32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_graphics4_IndexBuffer
#include <kha/graphics4/IndexBuffer.h>
#endif
#ifndef INCLUDED_kha_graphics4_Usage
#include <kha/graphics4/Usage.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexBuffer
#include <kha/graphics4/VertexBuffer.h>
#endif
#ifndef INCLUDED_kha_graphics4_VertexStructure
#include <kha/graphics4/VertexStructure.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_11092086db7ab145_101_new,"iron.data.Bucket","new",0xb14f6f1a,"iron.data.Bucket.new","iron/data/MeshBatch.hx",101,0xa201aaef)
HX_LOCAL_STACK_FRAME(_hx_pos_11092086db7ab145_113_remove,"iron.data.Bucket","remove",0xcd156dca,"iron.data.Bucket.remove","iron/data/MeshBatch.hx",113,0xa201aaef)
HX_LOCAL_STACK_FRAME(_hx_pos_11092086db7ab145_120_addMesh,"iron.data.Bucket","addMesh",0x37411068,"iron.data.Bucket.addMesh","iron/data/MeshBatch.hx",120,0xa201aaef)
HX_LOCAL_STACK_FRAME(_hx_pos_11092086db7ab145_124_removeMesh,"iron.data.Bucket","removeMesh",0xaaf390d7,"iron.data.Bucket.removeMesh","iron/data/MeshBatch.hx",124,0xa201aaef)
HX_LOCAL_STACK_FRAME(_hx_pos_11092086db7ab145_127_batch,"iron.data.Bucket","batch",0x4be728f4,"iron.data.Bucket.batch","iron/data/MeshBatch.hx",127,0xa201aaef)
namespace iron{
namespace data{

void Bucket_obj::__construct( ::iron::data::ShaderData shader){
            	HX_STACKFRAME(&_hx_pos_11092086db7ab145_101_new)
HXLINE( 107)		this->meshes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 103)		this->batched = false;
HXLINE( 110)		this->shader = shader;
            	}

Dynamic Bucket_obj::__CreateEmpty() { return new Bucket_obj; }

void *Bucket_obj::_hx_vtable = 0;

Dynamic Bucket_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Bucket_obj > _hx_result = new Bucket_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Bucket_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x1d32f57c;
}

void Bucket_obj::remove(){
            	HX_STACKFRAME(&_hx_pos_11092086db7ab145_113_remove)
HXLINE( 114)		this->vertexBuffer->_hx_delete();
HXLINE( 115)		this->indexBuffer->_hx_delete();
HXLINE( 116)		this->meshes = ::Array_obj< ::Dynamic>::__new(0);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Bucket_obj,remove,(void))

void Bucket_obj::addMesh( ::iron::object::MeshObject m){
            	HX_STACKFRAME(&_hx_pos_11092086db7ab145_120_addMesh)
HXDLIN( 120)		this->meshes->push(m);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Bucket_obj,addMesh,(void))

void Bucket_obj::removeMesh( ::iron::object::MeshObject m){
            	HX_STACKFRAME(&_hx_pos_11092086db7ab145_124_removeMesh)
HXDLIN( 124)		this->meshes->remove(m);
            	}


HX_DEFINE_DYNAMIC_FUNC1(Bucket_obj,removeMesh,(void))

void Bucket_obj::batch(){
            	HX_GC_STACKFRAME(&_hx_pos_11092086db7ab145_127_batch)
HXLINE( 128)		this->batched = true;
HXLINE( 131)		int vcount = (int)0;
HXLINE( 132)		int icount = (int)0;
HXLINE( 133)		::Array< ::Dynamic> mdatas = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 134)		{
HXLINE( 134)			int _g = (int)0;
HXDLIN( 134)			::Array< ::Dynamic> _g1 = this->meshes;
HXDLIN( 134)			while((_g < _g1->length)){
HXLINE( 134)				 ::iron::object::MeshObject m = _g1->__get(_g).StaticCast<  ::iron::object::MeshObject >();
HXDLIN( 134)				_g = (_g + (int)1);
HXLINE( 135)				bool mdFound = false;
HXLINE( 136)				{
HXLINE( 136)					int _g2 = (int)0;
HXDLIN( 136)					while((_g2 < mdatas->length)){
HXLINE( 136)						 ::iron::data::MeshData md = mdatas->__get(_g2).StaticCast<  ::iron::data::MeshData >();
HXDLIN( 136)						_g2 = (_g2 + (int)1);
HXLINE( 137)						if (hx::IsEq( m->data,md )) {
HXLINE( 138)							mdFound = true;
HXLINE( 139)							goto _hx_goto_5;
            						}
            					}
            					_hx_goto_5:;
            				}
HXLINE( 142)				if (!(mdFound)) {
HXLINE( 143)					mdatas->push(m->data);
HXLINE( 144)					m->data->start = icount;
HXLINE( 145)					int _hx_tmp = m->data->geom->indices->__get((int)0).StaticCast<  ::kha::arrays::Uint32ArrayPrivate >()->self.length();
HXDLIN( 145)					m->data->count = _hx_tmp;
HXLINE( 146)					icount = (icount + m->data->count);
HXLINE( 147)					vcount = (vcount + m->data->geom->getVerticesLength());
            				}
            			}
            		}
HXLINE( 151)		if ((mdatas->length == (int)0)) {
HXLINE( 151)			return;
            		}
HXLINE( 154)		this->vertexBuffer =  ::kha::graphics4::VertexBuffer_obj::__alloc( HX_CTX ,vcount,mdatas->__get((int)0).StaticCast<  ::iron::data::MeshData >()->geom->_hx_struct,::kha::graphics4::Usage_obj::StaticUsage_dyn(),null(),null());
HXLINE( 155)		 ::kha::arrays::Float32ArrayPrivate vertices = this->vertexBuffer->lock(null(),null());
HXLINE( 156)		int offset = (int)0;
HXLINE( 157)		{
HXLINE( 157)			int _g3 = (int)0;
HXDLIN( 157)			while((_g3 < mdatas->length)){
HXLINE( 157)				 ::iron::data::MeshData md1 = mdatas->__get(_g3).StaticCast<  ::iron::data::MeshData >();
HXDLIN( 157)				_g3 = (_g3 + (int)1);
HXLINE( 158)				md1->geom->copyVertices(vertices,offset);
HXLINE( 159)				offset = (offset + md1->geom->getVerticesLength());
            			}
            		}
HXLINE( 161)		this->vertexBuffer->unlock();
HXLINE( 163)		this->indexBuffer =  ::kha::graphics4::IndexBuffer_obj::__alloc( HX_CTX ,icount,::kha::graphics4::Usage_obj::StaticUsage_dyn(),null());
HXLINE( 164)		 ::kha::arrays::Uint32ArrayPrivate indices = this->indexBuffer->lock(null(),null());
HXLINE( 165)		int di = (int)-1;
HXLINE( 166)		int offset1 = (int)0;
HXLINE( 167)		{
HXLINE( 167)			int _g4 = (int)0;
HXDLIN( 167)			while((_g4 < mdatas->length)){
HXLINE( 167)				 ::iron::data::MeshData md2 = mdatas->__get(_g4).StaticCast<  ::iron::data::MeshData >();
HXDLIN( 167)				_g4 = (_g4 + (int)1);
HXLINE( 168)				{
HXLINE( 168)					int _g21 = (int)0;
HXDLIN( 168)					int _g11 = md2->geom->indices->__get((int)0).StaticCast<  ::kha::arrays::Uint32ArrayPrivate >()->self.length();
HXDLIN( 168)					while((_g21 < _g11)){
HXLINE( 168)						_g21 = (_g21 + (int)1);
HXDLIN( 168)						int i = (_g21 - (int)1);
HXLINE( 169)						{
HXLINE( 169)							di = (di + (int)1);
HXDLIN( 169)							int value = (md2->geom->indices->__get((int)0).StaticCast<  ::kha::arrays::Uint32ArrayPrivate >()->self.get(i) + offset1);
HXDLIN( 169)							indices->self.set(di,value);
            						}
            					}
            				}
HXLINE( 171)				int offset2 = md2->geom->getVerticesLength();
HXDLIN( 171)				offset1 = (offset1 + ::Std_obj::_hx_int(((Float)offset2 / (Float)md2->geom->structLength)));
            			}
            		}
HXLINE( 173)		this->indexBuffer->unlock();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Bucket_obj,batch,(void))


hx::ObjectPtr< Bucket_obj > Bucket_obj::__new( ::iron::data::ShaderData shader) {
	hx::ObjectPtr< Bucket_obj > __this = new Bucket_obj();
	__this->__construct(shader);
	return __this;
}

hx::ObjectPtr< Bucket_obj > Bucket_obj::__alloc(hx::Ctx *_hx_ctx, ::iron::data::ShaderData shader) {
	Bucket_obj *__this = (Bucket_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Bucket_obj), true, "iron.data.Bucket"));
	*(void **)__this = Bucket_obj::_hx_vtable;
	__this->__construct(shader);
	return __this;
}

Bucket_obj::Bucket_obj()
{
}

void Bucket_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Bucket);
	HX_MARK_MEMBER_NAME(batched,"batched");
	HX_MARK_MEMBER_NAME(shader,"shader");
	HX_MARK_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_MARK_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_MARK_MEMBER_NAME(meshes,"meshes");
	HX_MARK_END_CLASS();
}

void Bucket_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(batched,"batched");
	HX_VISIT_MEMBER_NAME(shader,"shader");
	HX_VISIT_MEMBER_NAME(vertexBuffer,"vertexBuffer");
	HX_VISIT_MEMBER_NAME(indexBuffer,"indexBuffer");
	HX_VISIT_MEMBER_NAME(meshes,"meshes");
}

hx::Val Bucket_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"batch") ) { return hx::Val( batch_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { return hx::Val( shader ); }
		if (HX_FIELD_EQ(inName,"meshes") ) { return hx::Val( meshes ); }
		if (HX_FIELD_EQ(inName,"remove") ) { return hx::Val( remove_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"batched") ) { return hx::Val( batched ); }
		if (HX_FIELD_EQ(inName,"addMesh") ) { return hx::Val( addMesh_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"removeMesh") ) { return hx::Val( removeMesh_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"indexBuffer") ) { return hx::Val( indexBuffer ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexBuffer") ) { return hx::Val( vertexBuffer ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Bucket_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"shader") ) { shader=inValue.Cast<  ::iron::data::ShaderData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"meshes") ) { meshes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"batched") ) { batched=inValue.Cast< bool >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"indexBuffer") ) { indexBuffer=inValue.Cast<  ::kha::graphics4::IndexBuffer >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vertexBuffer") ) { vertexBuffer=inValue.Cast<  ::kha::graphics4::VertexBuffer >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Bucket_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("batched","\x99","\x22","\x10","\xc0"));
	outFields->push(HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"));
	outFields->push(HX_HCSTRING("vertexBuffer","\x84","\xaf","\xa9","\x70"));
	outFields->push(HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5"));
	outFields->push(HX_HCSTRING("meshes","\x9b","\xb7","\xb1","\x08"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Bucket_obj_sMemberStorageInfo[] = {
	{hx::fsBool,(int)offsetof(Bucket_obj,batched),HX_HCSTRING("batched","\x99","\x22","\x10","\xc0")},
	{hx::fsObject /*::iron::data::ShaderData*/ ,(int)offsetof(Bucket_obj,shader),HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d")},
	{hx::fsObject /*::kha::graphics4::VertexBuffer*/ ,(int)offsetof(Bucket_obj,vertexBuffer),HX_HCSTRING("vertexBuffer","\x84","\xaf","\xa9","\x70")},
	{hx::fsObject /*::kha::graphics4::IndexBuffer*/ ,(int)offsetof(Bucket_obj,indexBuffer),HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(Bucket_obj,meshes),HX_HCSTRING("meshes","\x9b","\xb7","\xb1","\x08")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Bucket_obj_sStaticStorageInfo = 0;
#endif

static ::String Bucket_obj_sMemberFields[] = {
	HX_HCSTRING("batched","\x99","\x22","\x10","\xc0"),
	HX_HCSTRING("shader","\x25","\xbf","\x20","\x1d"),
	HX_HCSTRING("vertexBuffer","\x84","\xaf","\xa9","\x70"),
	HX_HCSTRING("indexBuffer","\xb2","\x65","\xa6","\xf5"),
	HX_HCSTRING("meshes","\x9b","\xb7","\xb1","\x08"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("addMesh","\xae","\x8c","\x96","\x84"),
	HX_HCSTRING("removeMesh","\x51","\x84","\x78","\xc5"),
	HX_HCSTRING("batch","\xba","\xe7","\xba","\xad"),
	::String(null()) };

static void Bucket_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Bucket_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Bucket_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Bucket_obj::__mClass,"__mClass");
};

#endif

hx::Class Bucket_obj::__mClass;

void Bucket_obj::__register()
{
	hx::Object *dummy = new Bucket_obj;
	Bucket_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("iron.data.Bucket","\x28","\x9a","\xb7","\x2d");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Bucket_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Bucket_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Bucket_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Bucket_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Bucket_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Bucket_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace iron
} // end namespace data
