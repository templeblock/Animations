// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_c5728fd05c542abe
#define INCLUDED_c5728fd05c542abe
#include "cpp_float32array.h"
#endif
#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_iron_Scene
#include <iron/Scene.h>
#endif
#ifndef INCLUDED_iron_data_CameraData
#include <iron/data/CameraData.h>
#endif
#ifndef INCLUDED_iron_data_Data
#include <iron/data/Data.h>
#endif
#ifndef INCLUDED_iron_data_LampData
#include <iron/data/LampData.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <iron/math/Vec4.h>
#endif
#ifndef INCLUDED_iron_object_CameraObject
#include <iron/object/CameraObject.h>
#endif
#ifndef INCLUDED_iron_object_FrustumPlane
#include <iron/object/FrustumPlane.h>
#endif
#ifndef INCLUDED_iron_object_LampObject
#include <iron/object/LampObject.h>
#endif
#ifndef INCLUDED_iron_object_Object
#include <iron/object/Object.h>
#endif
#ifndef INCLUDED_iron_object_Transform
#include <iron/object/Transform.h>
#endif
#ifndef INCLUDED_iron_object_Uniforms
#include <iron/object/Uniforms.h>
#endif
#ifndef INCLUDED_kha_System
#include <kha/System.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix4
#include <kha/math/FastMatrix4.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_acb023f1fcb194c9_10_new,"iron.object.LampObject","new",0xd9db57b2,"iron.object.LampObject.new","iron/object/LampObject.hx",10,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_57_remove,"iron.object.LampObject","remove",0x0b62f432,"iron.object.LampObject.remove","iron/object/LampObject.hx",57,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_74_buildMatrices,"iron.object.LampObject","buildMatrices",0x9bc888ba,"iron.object.LampObject.buildMatrices","iron/object/LampObject.hx",74,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_89_setCascade,"iron.object.LampObject","setCascade",0x0ac8bfa0,"iron.object.LampObject.setCascade","iron/object/LampObject.hx",89,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_205_updateViewFrustum,"iron.object.LampObject","updateViewFrustum",0x589622c6,"iron.object.LampObject.updateViewFrustum","iron/object/LampObject.hx",205,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_221_setCubeFace,"iron.object.LampObject","setCubeFace",0xed6d2f46,"iron.object.LampObject.setCubeFace","iron/object/LampObject.hx",221,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_253_getCascadeData,"iron.object.LampObject","getCascadeData",0xc4cda976,"iron.object.LampObject.getCascadeData","iron/object/LampObject.hx",253,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_293_right,"iron.object.LampObject","right",0xd9598bae,"iron.object.LampObject.right","iron/object/LampObject.hx",293,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_294_up,"iron.object.LampObject","up",0xe7b8af49,"iron.object.LampObject.up","iron/object/LampObject.hx",294,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_295_look,"iron.object.LampObject","look",0xc4c686cd,"iron.object.LampObject.look","iron/object/LampObject.hx",295,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_297_toString,"iron.object.LampObject","toString",0x6c81801a,"iron.object.LampObject.toString","iron/object/LampObject.hx",297,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_62_setCorners,"iron.object.LampObject","setCorners",0x17a9a66a,"iron.object.LampObject.setCorners","iron/object/LampObject.hx",62,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_87_mix,"iron.object.LampObject","mix",0xd9da98ee,"iron.object.LampObject.mix","iron/object/LampObject.hx",87,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_12_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",12,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_13_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",13,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_30_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",30,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_73_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",73,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_218_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",218,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_219_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",219,0xdc115dde)
HX_LOCAL_STACK_FRAME(_hx_pos_acb023f1fcb194c9_220_boot,"iron.object.LampObject","boot",0xbe2a64a0,"iron.object.LampObject.boot","iron/object/LampObject.hx",220,0xdc115dde)
namespace iron{
namespace object{

void LampObject_obj::__construct( ::iron::data::LampData data){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_10_new)
HXLINE( 252)		this->bias = ::iron::math::Mat4_obj::identity();
HXLINE(  29)		this->frustumPlanes = null();
HXLINE(  27)		this->VP = ::iron::math::Mat4_obj::identity();
HXLINE(  26)		this->P = null();
HXLINE(  25)		this->V = ::iron::math::Mat4_obj::identity();
HXLINE(  17)		this->camSlicedP = null();
HXLINE(  15)		this->cascadeData = null();
HXLINE(  33)		super::__construct();
HXLINE(  35)		this->data = data;
HXLINE(  37)		::String type = ( (::String)(data->raw->__Field(HX_("type",ba,f2,08,4d),hx::paccDynamic)) );
HXLINE(  38)		 ::Dynamic fov = data->raw->__Field(HX_("fov",0d,c7,4d,00),hx::paccDynamic);
HXLINE(  40)		if ((type == HX_("sun",8c,a9,57,00))) {
HXLINE(  41)			if (hx::IsNull( ::iron::object::LampObject_obj::corners )) {
HXLINE(  42)				::iron::object::LampObject_obj::corners = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  43)				{
HXLINE(  43)					int _g = (int)0;
HXDLIN(  43)					while((_g < (int)8)){
HXLINE(  43)						_g = (_g + (int)1);
HXDLIN(  43)						int i = (_g - (int)1);
HXDLIN(  43)						::Array< ::Dynamic> _hx_tmp = ::iron::object::LampObject_obj::corners;
HXDLIN(  43)						_hx_tmp->push( ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null()));
            					}
            				}
            			}
HXLINE(  45)			this->P = ::iron::math::Mat4_obj::identity();
            		}
            		else {
HXLINE(  47)			bool _hx_tmp1;
HXDLIN(  47)			if ((type != HX_("point",50,b4,8f,c6))) {
HXLINE(  47)				_hx_tmp1 = (type == HX_("area",8d,8b,74,40));
            			}
            			else {
HXLINE(  47)				_hx_tmp1 = true;
            			}
HXDLIN(  47)			if (_hx_tmp1) {
HXLINE(  48)				this->P = ::iron::math::Mat4_obj::persp(fov,(int)1,( (float)(data->raw->__Field(HX_("near_plane",85,54,5f,ca),hx::paccDynamic)) ),( (float)(data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) ));
            			}
            			else {
HXLINE(  50)				if ((type == HX_("spot",02,e7,58,4c))) {
HXLINE(  51)					this->P = ::iron::math::Mat4_obj::persp(fov,(int)1,( (float)(data->raw->__Field(HX_("near_plane",85,54,5f,ca),hx::paccDynamic)) ),( (float)(data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) ));
            				}
            			}
            		}
HXLINE(  54)		::iron::Scene_obj::active->lamps->push(hx::ObjectPtr<OBJ_>(this));
            	}

Dynamic LampObject_obj::__CreateEmpty() { return new LampObject_obj; }

void *LampObject_obj::_hx_vtable = 0;

Dynamic LampObject_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< LampObject_obj > _hx_result = new LampObject_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool LampObject_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x2a486766) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x2a486766;
	} else {
		return inClassId==(int)0x3a1da21e;
	}
}

void LampObject_obj::remove(){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_57_remove)
HXLINE(  58)		if (hx::IsNotNull( ::iron::Scene_obj::active )) {
HXLINE(  58)			::iron::Scene_obj::active->lamps->remove(hx::ObjectPtr<OBJ_>(this));
            		}
HXLINE(  59)		this->super::remove();
            	}


void LampObject_obj::buildMatrices( ::iron::object::CameraObject camera){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_74_buildMatrices)
HXLINE(  75)		this->transform->buildMatrix();
HXLINE(  76)		if ((( (::String)(this->data->raw->__Field(HX_("type",ba,f2,08,4d),hx::paccDynamic)) ) != HX_("sun",8c,a9,57,00))) {
HXLINE(  82)			this->V->getInverse(this->transform->world);
HXLINE(  83)			this->updateViewFrustum(camera);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(LampObject_obj,buildMatrices,(void))

void LampObject_obj::setCascade( ::iron::object::CameraObject camera,int cascade){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_89_setCascade)
HXLINE(  94)		::iron::object::LampObject_obj::m->setFrom(camera->V);
HXLINE( 103)		if (hx::IsNull( this->camSlicedP )) {
HXLINE( 104)			this->camSlicedP = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 105)			this->cascadeSplit = ::Array_obj< Float >::__new(0);
HXLINE( 106)			 ::Dynamic aspect;
HXDLIN( 106)			if (hx::IsNotNull( camera->data->raw->__Field(HX_("aspect",d8,95,07,4a),hx::paccDynamic) )) {
HXLINE( 106)				aspect = camera->data->raw->__Field(HX_("aspect",d8,95,07,4a),hx::paccDynamic);
            			}
            			else {
HXLINE( 106)				int aspect1 = ::kha::System_obj::windowWidth(null());
HXDLIN( 106)				aspect = ((Float)aspect1 / (Float)::kha::System_obj::windowHeight(null()));
            			}
HXLINE( 107)			float fov = ( (float)(camera->data->raw->__Field(HX_("fov",0d,c7,4d,00),hx::paccDynamic)) );
HXLINE( 108)			float _hx_near = ( (float)(camera->data->raw->__Field(HX_("near_plane",85,54,5f,ca),hx::paccDynamic)) );
HXLINE( 109)			float _hx_far = ( (float)(camera->data->raw->__Field(HX_("far_plane",b4,3b,51,fd),hx::paccDynamic)) );
HXLINE( 110)			Float factor;
HXDLIN( 110)			if ((::iron::object::LampObject_obj::cascadeCount > (int)2)) {
HXLINE( 110)				factor = ::iron::object::LampObject_obj::cascadeSplitFactor;
            			}
            			else {
HXLINE( 110)				factor = (::iron::object::LampObject_obj::cascadeSplitFactor * ((Float)0.25));
            			}
HXLINE( 111)			{
HXLINE( 111)				int _g1 = (int)0;
HXDLIN( 111)				int _g = ::iron::object::LampObject_obj::cascadeCount;
HXDLIN( 111)				while((_g1 < _g)){
HXLINE( 111)					_g1 = (_g1 + (int)1);
HXDLIN( 111)					int i = (_g1 - (int)1);
HXLINE( 112)					Float f = (i + ((Float)1.0));
HXLINE( 114)					Float a = ((Float)f / (Float)::iron::object::LampObject_obj::cascadeCount);
HXLINE( 113)					Float cfar = (((_hx_near + (a * (_hx_far - _hx_near))) * ((int)1 - factor)) + ((_hx_near * ::Math_obj::pow(((Float)_hx_far / (Float)_hx_near),((Float)f / (Float)::iron::object::LampObject_obj::cascadeCount))) * factor));
HXLINE( 117)					this->cascadeSplit->push(cfar);
HXLINE( 118)					::Array< ::Dynamic> _hx_tmp = this->camSlicedP;
HXDLIN( 118)					_hx_tmp->push(::iron::math::Mat4_obj::persp(fov,aspect,_hx_near,cfar));
            				}
            			}
            		}
HXLINE( 121)		 ::iron::math::Mat4 _hx_tmp1 = ::iron::object::LampObject_obj::m;
HXDLIN( 121)		_hx_tmp1->multmat2(this->camSlicedP->__get(cascade).StaticCast<  ::iron::math::Mat4 >());
HXLINE( 133)		::iron::object::LampObject_obj::m->getInverse(::iron::object::LampObject_obj::m);
HXLINE( 134)		this->V->getInverse(this->transform->world);
HXLINE( 135)		this->V->toRotation();
HXLINE( 136)		::iron::object::LampObject_obj::m->multmat2(this->V);
HXLINE( 137)		::iron::object::LampObject_obj::setCorners();
HXLINE( 138)		{
HXLINE( 138)			int _g2 = (int)0;
HXDLIN( 138)			::Array< ::Dynamic> _g11 = ::iron::object::LampObject_obj::corners;
HXDLIN( 138)			while((_g2 < _g11->length)){
HXLINE( 138)				 ::iron::math::Vec4 v = _g11->__get(_g2).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 138)				_g2 = (_g2 + (int)1);
HXLINE( 139)				v->applymat4(::iron::object::LampObject_obj::m);
HXLINE( 140)				Float _hx_tmp2 = ((Float)v->x / (Float)v->w);
HXDLIN( 140)				Float _hx_tmp3 = ((Float)v->y / (Float)v->w);
HXDLIN( 140)				v->set(_hx_tmp2,_hx_tmp3,((Float)v->z / (Float)v->w),null());
            			}
            		}
HXLINE( 143)		float minx = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->x;
HXLINE( 144)		float miny = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->y;
HXLINE( 145)		float minz = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->z;
HXLINE( 146)		float maxx = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->x;
HXLINE( 147)		float maxy = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->y;
HXLINE( 148)		float maxz = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->z;
HXLINE( 149)		{
HXLINE( 149)			int _g3 = (int)0;
HXDLIN( 149)			::Array< ::Dynamic> _g12 = ::iron::object::LampObject_obj::corners;
HXDLIN( 149)			while((_g3 < _g12->length)){
HXLINE( 149)				 ::iron::math::Vec4 v1 = _g12->__get(_g3).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 149)				_g3 = (_g3 + (int)1);
HXLINE( 150)				if ((v1->x < minx)) {
HXLINE( 150)					minx = v1->x;
            				}
HXLINE( 151)				if ((v1->x > maxx)) {
HXLINE( 151)					maxx = v1->x;
            				}
HXLINE( 152)				if ((v1->y < miny)) {
HXLINE( 152)					miny = v1->y;
            				}
HXLINE( 153)				if ((v1->y > maxy)) {
HXLINE( 153)					maxy = v1->y;
            				}
HXLINE( 154)				if ((v1->z < minz)) {
HXLINE( 154)					minz = v1->z;
            				}
HXLINE( 155)				if ((v1->z > maxz)) {
HXLINE( 155)					maxz = v1->z;
            				}
            			}
            		}
HXLINE( 159)		 ::iron::math::Vec4 v11 = ::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 159)		 ::iron::math::Vec4 v2 = ::iron::object::LampObject_obj::corners->__get((int)7).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 159)		float vx = (v11->x - v2->x);
HXDLIN( 159)		float vy = (v11->y - v2->y);
HXDLIN( 159)		float vz = (v11->z - v2->z);
HXDLIN( 159)		float diag0 = ::Math_obj::sqrt((((vx * vx) + (vy * vy)) + (vz * vz)));
HXLINE( 160)		Float offx = ((diag0 - (maxx - minx)) * ((Float)0.5));
HXLINE( 161)		Float offy = ((diag0 - (maxy - miny)) * ((Float)0.5));
HXLINE( 162)		minx = (minx - offx);
HXLINE( 163)		maxx = (maxx + offx);
HXLINE( 164)		miny = (miny - offy);
HXLINE( 165)		maxy = (maxy + offy);
HXLINE( 168)		 ::Dynamic smsize = this->data->raw->__Field(HX_("shadowmap_size",64,64,75,5c),hx::paccDynamic);
HXLINE( 170)		smsize = ::Std_obj::_hx_int(((Float)smsize / (Float)(int)4));
HXLINE( 172)		Float worldPerTexelX = ((Float)(maxx - minx) / (Float)smsize);
HXLINE( 173)		Float worldPerTexelY = ((Float)(maxy - miny) / (Float)smsize);
HXLINE( 174)		Float worldPerTexelZ = ((Float)(maxz - minz) / (Float)smsize);
HXLINE( 175)		minx = (::Math_obj::floor(((Float)minx / (Float)worldPerTexelX)) * worldPerTexelX);
HXLINE( 176)		miny = (::Math_obj::floor(((Float)miny / (Float)worldPerTexelY)) * worldPerTexelY);
HXLINE( 177)		minz = (::Math_obj::floor(((Float)minz / (Float)worldPerTexelZ)) * worldPerTexelZ);
HXLINE( 178)		maxx = (::Math_obj::floor(((Float)maxx / (Float)worldPerTexelX)) * worldPerTexelX);
HXLINE( 179)		maxy = (::Math_obj::floor(((Float)maxy / (Float)worldPerTexelY)) * worldPerTexelY);
HXLINE( 180)		maxz = (::Math_obj::floor(((Float)maxz / (Float)worldPerTexelZ)) * worldPerTexelZ);
HXLINE( 182)		Float hx = ((Float)(maxx - minx) / (Float)(int)2);
HXLINE( 183)		Float hy = ((Float)(maxy - miny) / (Float)(int)2);
HXLINE( 184)		Float hz = ((Float)(maxz - minz) / (Float)(int)2);
HXLINE( 185)		this->V->self->_30 = -((minx + hx));
HXLINE( 186)		this->V->self->_31 = -((miny + hy));
HXLINE( 187)		this->V->self->_32 = -((minz + hz));
HXLINE( 189)		::iron::object::LampObject_obj::m = ::iron::math::Mat4_obj::ortho(-(hx),hx,-(hy),hy,(-(hz) * (int)4),hz);
HXLINE( 190)		this->P->setFrom(::iron::object::LampObject_obj::m);
HXLINE( 192)		this->updateViewFrustum(camera);
HXLINE( 195)		if (hx::IsNull( this->cascadeVP )) {
HXLINE( 196)			this->cascadeVP = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 197)			{
HXLINE( 197)				int _g13 = (int)0;
HXDLIN( 197)				int _g4 = ::iron::object::LampObject_obj::cascadeCount;
HXDLIN( 197)				while((_g13 < _g4)){
HXLINE( 197)					_g13 = (_g13 + (int)1);
HXDLIN( 197)					int i1 = (_g13 - (int)1);
HXLINE( 198)					::Array< ::Dynamic> _hx_tmp4 = this->cascadeVP;
HXDLIN( 198)					_hx_tmp4->push(::iron::math::Mat4_obj::identity());
            				}
            			}
            		}
HXLINE( 201)		this->cascadeVP->__get(cascade).StaticCast<  ::iron::math::Mat4 >()->setFrom(this->VP);
            	}


HX_DEFINE_DYNAMIC_FUNC2(LampObject_obj,setCascade,(void))

void LampObject_obj::updateViewFrustum( ::iron::object::CameraObject camera){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_205_updateViewFrustum)
HXLINE( 206)		this->VP->multmats(this->P,this->V);
HXLINE( 209)		if (( (bool)(camera->data->raw->__Field(HX_("frustum_culling",53,b5,43,1c),hx::paccDynamic)) )) {
HXLINE( 210)			if (hx::IsNull( this->frustumPlanes )) {
HXLINE( 211)				this->frustumPlanes = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 212)				{
HXLINE( 212)					int _g = (int)0;
HXDLIN( 212)					while((_g < (int)6)){
HXLINE( 212)						_g = (_g + (int)1);
HXDLIN( 212)						int i = (_g - (int)1);
HXDLIN( 212)						::Array< ::Dynamic> _hx_tmp = this->frustumPlanes;
HXDLIN( 212)						_hx_tmp->push( ::iron::object::FrustumPlane_obj::__alloc( HX_CTX ));
            					}
            				}
            			}
HXLINE( 214)			::iron::object::CameraObject_obj::buildViewFrustum(this->VP,this->frustumPlanes);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(LampObject_obj,updateViewFrustum,(void))

void LampObject_obj::setCubeFace(int face, ::iron::object::CameraObject camera){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_221_setCubeFace)
HXLINE( 223)		::iron::object::LampObject_obj::p1->set(this->transform->world->self->_30,this->transform->world->self->_31,this->transform->world->self->_32,null());
HXLINE( 224)		::iron::object::LampObject_obj::p2->setFrom(::iron::object::LampObject_obj::p1);
HXLINE( 226)		switch((int)(face)){
            			case (int)0: {
HXLINE( 228)				::iron::object::LampObject_obj::p2->addf(((Float)1.0),((Float)0.0),((Float)0.0));
HXLINE( 229)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)-1.0),((Float)0.0),null());
            			}
            			break;
            			case (int)1: {
HXLINE( 231)				::iron::object::LampObject_obj::p2->addf(((Float)-1.0),((Float)0.0),((Float)0.0));
HXLINE( 232)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)-1.0),((Float)0.0),null());
            			}
            			break;
            			case (int)2: {
HXLINE( 234)				::iron::object::LampObject_obj::p2->addf(((Float)0.0),((Float)1.0),((Float)0.0));
HXLINE( 235)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)0.0),((Float)1.0),null());
            			}
            			break;
            			case (int)3: {
HXLINE( 237)				::iron::object::LampObject_obj::p2->addf(((Float)0.0),((Float)-1.0),((Float)0.0));
HXLINE( 238)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)0.0),((Float)-1.0),null());
            			}
            			break;
            			case (int)4: {
HXLINE( 240)				::iron::object::LampObject_obj::p2->addf(((Float)0.0),((Float)0.0),((Float)1.0));
HXLINE( 241)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)-1.0),((Float)0.0),null());
            			}
            			break;
            			case (int)5: {
HXLINE( 243)				::iron::object::LampObject_obj::p2->addf(((Float)0.0),((Float)0.0),((Float)-1.0));
HXLINE( 244)				::iron::object::LampObject_obj::p3->set(((Float)0.0),((Float)-1.0),((Float)0.0),null());
            			}
            			break;
            		}
HXLINE( 247)		this->V->setLookAt(::iron::object::LampObject_obj::p1,::iron::object::LampObject_obj::p2,::iron::object::LampObject_obj::p3);
HXLINE( 248)		this->updateViewFrustum(camera);
            	}


HX_DEFINE_DYNAMIC_FUNC2(LampObject_obj,setCubeFace,(void))

 ::kha::arrays::Float32ArrayPrivate LampObject_obj::getCascadeData(){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_253_getCascadeData)
HXLINE( 255)		if (hx::IsNull( this->cascadeData )) {
HXLINE( 256)			 ::kha::arrays::Float32ArrayPrivate this1 =  ::kha::arrays::Float32ArrayPrivate_obj::__alloc( HX_CTX ,((::iron::object::LampObject_obj::cascadeCount * (int)16) + (int)4));
HXDLIN( 256)			this->cascadeData = this1;
            		}
HXLINE( 258)		if (hx::IsNull( this->cascadeVP )) {
HXLINE( 258)			return this->cascadeData;
            		}
HXLINE( 261)		{
HXLINE( 261)			int _g1 = (int)0;
HXDLIN( 261)			int _g = ::iron::object::LampObject_obj::cascadeCount;
HXDLIN( 261)			while((_g1 < _g)){
HXLINE( 261)				_g1 = (_g1 + (int)1);
HXDLIN( 261)				int i = (_g1 - (int)1);
HXLINE( 262)				 ::iron::math::Mat4 _hx_tmp = ::iron::object::LampObject_obj::m;
HXDLIN( 262)				_hx_tmp->setFrom(this->cascadeVP->__get(i).StaticCast<  ::iron::math::Mat4 >());
HXLINE( 263)				this->bias->setFrom(::iron::object::Uniforms_obj::biasMat);
HXLINE( 264)				{
HXLINE( 264)					 ::iron::math::Mat4 _g2 = this->bias;
HXDLIN( 264)					_g2->self->_00 = ((Float)_g2->self->_00 / (Float)::iron::object::LampObject_obj::cascadeCount);
            				}
HXLINE( 265)				{
HXLINE( 265)					 ::iron::math::Mat4 _g21 = this->bias;
HXDLIN( 265)					_g21->self->_30 = ((Float)_g21->self->_30 / (Float)::iron::object::LampObject_obj::cascadeCount);
            				}
HXLINE( 266)				{
HXLINE( 266)					 ::iron::math::Mat4 _g22 = this->bias;
HXDLIN( 266)					{
HXLINE( 266)						float _g23 = _g22->self->_30;
HXDLIN( 266)						_g22->self->_30 = (_g23 + (i * ((Float)(int)1 / (Float)::iron::object::LampObject_obj::cascadeCount)));
            					}
            				}
HXLINE( 267)				::iron::object::LampObject_obj::m->multmat2(this->bias);
HXLINE( 268)				{
HXLINE( 268)					 float32array this2 = this->cascadeData->self;
HXDLIN( 268)					this2.set((i * (int)16),::iron::object::LampObject_obj::m->self->_00);
            				}
HXLINE( 269)				{
HXLINE( 269)					 float32array this3 = this->cascadeData->self;
HXDLIN( 269)					this3.set(((i * (int)16) + (int)1),::iron::object::LampObject_obj::m->self->_01);
            				}
HXLINE( 270)				{
HXLINE( 270)					 float32array this4 = this->cascadeData->self;
HXDLIN( 270)					this4.set(((i * (int)16) + (int)2),::iron::object::LampObject_obj::m->self->_02);
            				}
HXLINE( 271)				{
HXLINE( 271)					 float32array this5 = this->cascadeData->self;
HXDLIN( 271)					this5.set(((i * (int)16) + (int)3),::iron::object::LampObject_obj::m->self->_03);
            				}
HXLINE( 272)				{
HXLINE( 272)					 float32array this6 = this->cascadeData->self;
HXDLIN( 272)					this6.set(((i * (int)16) + (int)4),::iron::object::LampObject_obj::m->self->_10);
            				}
HXLINE( 273)				{
HXLINE( 273)					 float32array this7 = this->cascadeData->self;
HXDLIN( 273)					this7.set(((i * (int)16) + (int)5),::iron::object::LampObject_obj::m->self->_11);
            				}
HXLINE( 274)				{
HXLINE( 274)					 float32array this8 = this->cascadeData->self;
HXDLIN( 274)					this8.set(((i * (int)16) + (int)6),::iron::object::LampObject_obj::m->self->_12);
            				}
HXLINE( 275)				{
HXLINE( 275)					 float32array this9 = this->cascadeData->self;
HXDLIN( 275)					this9.set(((i * (int)16) + (int)7),::iron::object::LampObject_obj::m->self->_13);
            				}
HXLINE( 276)				{
HXLINE( 276)					 float32array this10 = this->cascadeData->self;
HXDLIN( 276)					this10.set(((i * (int)16) + (int)8),::iron::object::LampObject_obj::m->self->_20);
            				}
HXLINE( 277)				{
HXLINE( 277)					 float32array this11 = this->cascadeData->self;
HXDLIN( 277)					this11.set(((i * (int)16) + (int)9),::iron::object::LampObject_obj::m->self->_21);
            				}
HXLINE( 278)				{
HXLINE( 278)					 float32array this12 = this->cascadeData->self;
HXDLIN( 278)					this12.set(((i * (int)16) + (int)10),::iron::object::LampObject_obj::m->self->_22);
            				}
HXLINE( 279)				{
HXLINE( 279)					 float32array this13 = this->cascadeData->self;
HXDLIN( 279)					this13.set(((i * (int)16) + (int)11),::iron::object::LampObject_obj::m->self->_23);
            				}
HXLINE( 280)				{
HXLINE( 280)					 float32array this14 = this->cascadeData->self;
HXDLIN( 280)					this14.set(((i * (int)16) + (int)12),::iron::object::LampObject_obj::m->self->_30);
            				}
HXLINE( 281)				{
HXLINE( 281)					 float32array this15 = this->cascadeData->self;
HXDLIN( 281)					this15.set(((i * (int)16) + (int)13),::iron::object::LampObject_obj::m->self->_31);
            				}
HXLINE( 282)				{
HXLINE( 282)					 float32array this16 = this->cascadeData->self;
HXDLIN( 282)					this16.set(((i * (int)16) + (int)14),::iron::object::LampObject_obj::m->self->_32);
            				}
HXLINE( 283)				{
HXLINE( 283)					 float32array this17 = this->cascadeData->self;
HXDLIN( 283)					this17.set(((i * (int)16) + (int)15),::iron::object::LampObject_obj::m->self->_33);
            				}
            			}
            		}
HXLINE( 285)		this->cascadeData->self.set((::iron::object::LampObject_obj::cascadeCount * (int)16),this->cascadeSplit->__get((int)0));
HXLINE( 286)		this->cascadeData->self.set(((::iron::object::LampObject_obj::cascadeCount * (int)16) + (int)1),this->cascadeSplit->__get((int)1));
HXLINE( 287)		this->cascadeData->self.set(((::iron::object::LampObject_obj::cascadeCount * (int)16) + (int)2),this->cascadeSplit->__get((int)2));
HXLINE( 288)		this->cascadeData->self.set(((::iron::object::LampObject_obj::cascadeCount * (int)16) + (int)3),this->cascadeSplit->__get((int)3));
HXLINE( 289)		return this->cascadeData;
            	}


HX_DEFINE_DYNAMIC_FUNC0(LampObject_obj,getCascadeData,return )

 ::iron::math::Vec4 LampObject_obj::right(){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_293_right)
HXDLIN( 293)		return  ::iron::math::Vec4_obj::__alloc( HX_CTX ,this->V->self->_00,this->V->self->_10,this->V->self->_20,null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(LampObject_obj,right,return )

 ::iron::math::Vec4 LampObject_obj::up(){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_294_up)
HXDLIN( 294)		return  ::iron::math::Vec4_obj::__alloc( HX_CTX ,this->V->self->_01,this->V->self->_11,this->V->self->_21,null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(LampObject_obj,up,return )

 ::iron::math::Vec4 LampObject_obj::look(){
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_295_look)
HXDLIN( 295)		return  ::iron::math::Vec4_obj::__alloc( HX_CTX ,this->V->self->_02,this->V->self->_12,this->V->self->_22,null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(LampObject_obj,look,return )

::String LampObject_obj::toString(){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_297_toString)
HXDLIN( 297)		return (HX_("Lamp Object ",79,fd,5c,f8) + this->name);
            	}


int LampObject_obj::cascadeCount;

Float LampObject_obj::cascadeSplitFactor;

::Array< ::Dynamic> LampObject_obj::corners;

void LampObject_obj::setCorners(){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_62_setCorners)
HXLINE(  63)		::iron::object::LampObject_obj::corners->__get((int)0).StaticCast<  ::iron::math::Vec4 >()->set(((Float)-1.0),((Float)-1.0),((Float)1.0),null());
HXLINE(  64)		::iron::object::LampObject_obj::corners->__get((int)1).StaticCast<  ::iron::math::Vec4 >()->set(((Float)-1.0),((Float)-1.0),((Float)-1.0),null());
HXLINE(  65)		::iron::object::LampObject_obj::corners->__get((int)2).StaticCast<  ::iron::math::Vec4 >()->set(((Float)-1.0),((Float)1.0),((Float)1.0),null());
HXLINE(  66)		::iron::object::LampObject_obj::corners->__get((int)3).StaticCast<  ::iron::math::Vec4 >()->set(((Float)-1.0),((Float)1.0),((Float)-1.0),null());
HXLINE(  67)		::iron::object::LampObject_obj::corners->__get((int)4).StaticCast<  ::iron::math::Vec4 >()->set(((Float)1.0),((Float)-1.0),((Float)1.0),null());
HXLINE(  68)		::iron::object::LampObject_obj::corners->__get((int)5).StaticCast<  ::iron::math::Vec4 >()->set(((Float)1.0),((Float)-1.0),((Float)-1.0),null());
HXLINE(  69)		::iron::object::LampObject_obj::corners->__get((int)6).StaticCast<  ::iron::math::Vec4 >()->set(((Float)1.0),((Float)1.0),((Float)1.0),null());
HXLINE(  70)		::iron::object::LampObject_obj::corners->__get((int)7).StaticCast<  ::iron::math::Vec4 >()->set(((Float)1.0),((Float)1.0),((Float)-1.0),null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(LampObject_obj,setCorners,(void))

 ::iron::math::Mat4 LampObject_obj::m;

Float LampObject_obj::mix(Float a,Float b,Float f){
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_87_mix)
HXDLIN(  87)		return ((a * ((int)1 - f)) + (b * f));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(LampObject_obj,mix,return )

 ::iron::math::Vec4 LampObject_obj::p1;

 ::iron::math::Vec4 LampObject_obj::p2;

 ::iron::math::Vec4 LampObject_obj::p3;


hx::ObjectPtr< LampObject_obj > LampObject_obj::__new( ::iron::data::LampData data) {
	hx::ObjectPtr< LampObject_obj > __this = new LampObject_obj();
	__this->__construct(data);
	return __this;
}

hx::ObjectPtr< LampObject_obj > LampObject_obj::__alloc(hx::Ctx *_hx_ctx, ::iron::data::LampData data) {
	LampObject_obj *__this = (LampObject_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(LampObject_obj), true, "iron.object.LampObject"));
	*(void **)__this = LampObject_obj::_hx_vtable;
	__this->__construct(data);
	return __this;
}

LampObject_obj::LampObject_obj()
{
}

void LampObject_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(LampObject);
	HX_MARK_MEMBER_NAME(cascadeData,"cascadeData");
	HX_MARK_MEMBER_NAME(cascadeVP,"cascadeVP");
	HX_MARK_MEMBER_NAME(camSlicedP,"camSlicedP");
	HX_MARK_MEMBER_NAME(cascadeSplit,"cascadeSplit");
	HX_MARK_MEMBER_NAME(data,"data");
	HX_MARK_MEMBER_NAME(V,"V");
	HX_MARK_MEMBER_NAME(P,"P");
	HX_MARK_MEMBER_NAME(VP,"VP");
	HX_MARK_MEMBER_NAME(frustumPlanes,"frustumPlanes");
	HX_MARK_MEMBER_NAME(bias,"bias");
	 ::iron::object::Object_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void LampObject_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(cascadeData,"cascadeData");
	HX_VISIT_MEMBER_NAME(cascadeVP,"cascadeVP");
	HX_VISIT_MEMBER_NAME(camSlicedP,"camSlicedP");
	HX_VISIT_MEMBER_NAME(cascadeSplit,"cascadeSplit");
	HX_VISIT_MEMBER_NAME(data,"data");
	HX_VISIT_MEMBER_NAME(V,"V");
	HX_VISIT_MEMBER_NAME(P,"P");
	HX_VISIT_MEMBER_NAME(VP,"VP");
	HX_VISIT_MEMBER_NAME(frustumPlanes,"frustumPlanes");
	HX_VISIT_MEMBER_NAME(bias,"bias");
	 ::iron::object::Object_obj::__Visit(HX_VISIT_ARG);
}

hx::Val LampObject_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"V") ) { return hx::Val( V ); }
		if (HX_FIELD_EQ(inName,"P") ) { return hx::Val( P ); }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"VP") ) { return hx::Val( VP ); }
		if (HX_FIELD_EQ(inName,"up") ) { return hx::Val( up_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { return hx::Val( data ); }
		if (HX_FIELD_EQ(inName,"bias") ) { return hx::Val( bias ); }
		if (HX_FIELD_EQ(inName,"look") ) { return hx::Val( look_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"right") ) { return hx::Val( right_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"remove") ) { return hx::Val( remove_dyn() ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"toString") ) { return hx::Val( toString_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cascadeVP") ) { return hx::Val( cascadeVP ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"camSlicedP") ) { return hx::Val( camSlicedP ); }
		if (HX_FIELD_EQ(inName,"setCascade") ) { return hx::Val( setCascade_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cascadeData") ) { return hx::Val( cascadeData ); }
		if (HX_FIELD_EQ(inName,"setCubeFace") ) { return hx::Val( setCubeFace_dyn() ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cascadeSplit") ) { return hx::Val( cascadeSplit ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"frustumPlanes") ) { return hx::Val( frustumPlanes ); }
		if (HX_FIELD_EQ(inName,"buildMatrices") ) { return hx::Val( buildMatrices_dyn() ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getCascadeData") ) { return hx::Val( getCascadeData_dyn() ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"updateViewFrustum") ) { return hx::Val( updateViewFrustum_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool LampObject_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"m") ) { outValue = ( m ); return true; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"p1") ) { outValue = ( p1 ); return true; }
		if (HX_FIELD_EQ(inName,"p2") ) { outValue = ( p2 ); return true; }
		if (HX_FIELD_EQ(inName,"p3") ) { outValue = ( p3 ); return true; }
		break;
	case 3:
		if (HX_FIELD_EQ(inName,"mix") ) { outValue = mix_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"corners") ) { outValue = ( corners ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"setCorners") ) { outValue = setCorners_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cascadeCount") ) { outValue = ( cascadeCount ); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"cascadeSplitFactor") ) { outValue = ( cascadeSplitFactor ); return true; }
	}
	return false;
}

hx::Val LampObject_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"V") ) { V=inValue.Cast<  ::iron::math::Mat4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"P") ) { P=inValue.Cast<  ::iron::math::Mat4 >(); return inValue; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"VP") ) { VP=inValue.Cast<  ::iron::math::Mat4 >(); return inValue; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"data") ) { data=inValue.Cast<  ::iron::data::LampData >(); return inValue; }
		if (HX_FIELD_EQ(inName,"bias") ) { bias=inValue.Cast<  ::iron::math::Mat4 >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"cascadeVP") ) { cascadeVP=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"camSlicedP") ) { camSlicedP=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"cascadeData") ) { cascadeData=inValue.Cast<  ::kha::arrays::Float32ArrayPrivate >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cascadeSplit") ) { cascadeSplit=inValue.Cast< ::Array< Float > >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"frustumPlanes") ) { frustumPlanes=inValue.Cast< ::Array< ::Dynamic> >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool LampObject_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"m") ) { m=ioValue.Cast<  ::iron::math::Mat4 >(); return true; }
		break;
	case 2:
		if (HX_FIELD_EQ(inName,"p1") ) { p1=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		if (HX_FIELD_EQ(inName,"p2") ) { p2=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		if (HX_FIELD_EQ(inName,"p3") ) { p3=ioValue.Cast<  ::iron::math::Vec4 >(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"corners") ) { corners=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"cascadeCount") ) { cascadeCount=ioValue.Cast< int >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"cascadeSplitFactor") ) { cascadeSplitFactor=ioValue.Cast< Float >(); return true; }
	}
	return false;
}

void LampObject_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("cascadeData","\x7e","\x60","\x36","\xa5"));
	outFields->push(HX_HCSTRING("cascadeVP","\x6e","\x74","\x36","\x9f"));
	outFields->push(HX_HCSTRING("camSlicedP","\xef","\x37","\x90","\x05"));
	outFields->push(HX_HCSTRING("cascadeSplit","\x06","\xea","\x44","\x97"));
	outFields->push(HX_HCSTRING("data","\x2a","\x56","\x63","\x42"));
	outFields->push(HX_HCSTRING("V","\x56","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("P","\x50","\x00","\x00","\x00"));
	outFields->push(HX_HCSTRING("VP","\x3a","\x4b","\x00","\x00"));
	outFields->push(HX_HCSTRING("frustumPlanes","\x99","\x03","\x66","\x33"));
	outFields->push(HX_HCSTRING("bias","\x79","\xea","\x16","\x41"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo LampObject_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::kha::arrays::Float32ArrayPrivate*/ ,(int)offsetof(LampObject_obj,cascadeData),HX_HCSTRING("cascadeData","\x7e","\x60","\x36","\xa5")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(LampObject_obj,cascadeVP),HX_HCSTRING("cascadeVP","\x6e","\x74","\x36","\x9f")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(LampObject_obj,camSlicedP),HX_HCSTRING("camSlicedP","\xef","\x37","\x90","\x05")},
	{hx::fsObject /*Array< Float >*/ ,(int)offsetof(LampObject_obj,cascadeSplit),HX_HCSTRING("cascadeSplit","\x06","\xea","\x44","\x97")},
	{hx::fsObject /*::iron::data::LampData*/ ,(int)offsetof(LampObject_obj,data),HX_HCSTRING("data","\x2a","\x56","\x63","\x42")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(int)offsetof(LampObject_obj,V),HX_HCSTRING("V","\x56","\x00","\x00","\x00")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(int)offsetof(LampObject_obj,P),HX_HCSTRING("P","\x50","\x00","\x00","\x00")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(int)offsetof(LampObject_obj,VP),HX_HCSTRING("VP","\x3a","\x4b","\x00","\x00")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(int)offsetof(LampObject_obj,frustumPlanes),HX_HCSTRING("frustumPlanes","\x99","\x03","\x66","\x33")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(int)offsetof(LampObject_obj,bias),HX_HCSTRING("bias","\x79","\xea","\x16","\x41")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo LampObject_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &LampObject_obj::cascadeCount,HX_HCSTRING("cascadeCount","\xfb","\x43","\x39","\x60")},
	{hx::fsFloat,(void *) &LampObject_obj::cascadeSplitFactor,HX_HCSTRING("cascadeSplitFactor","\x75","\x3f","\xf3","\x12")},
	{hx::fsObject /*Array< ::Dynamic >*/ ,(void *) &LampObject_obj::corners,HX_HCSTRING("corners","\xfe","\x9a","\x1a","\x63")},
	{hx::fsObject /*::iron::math::Mat4*/ ,(void *) &LampObject_obj::m,HX_HCSTRING("m","\x6d","\x00","\x00","\x00")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &LampObject_obj::p1,HX_HCSTRING("p1","\xc1","\x61","\x00","\x00")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &LampObject_obj::p2,HX_HCSTRING("p2","\xc2","\x61","\x00","\x00")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(void *) &LampObject_obj::p3,HX_HCSTRING("p3","\xc3","\x61","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String LampObject_obj_sMemberFields[] = {
	HX_HCSTRING("cascadeData","\x7e","\x60","\x36","\xa5"),
	HX_HCSTRING("cascadeVP","\x6e","\x74","\x36","\x9f"),
	HX_HCSTRING("camSlicedP","\xef","\x37","\x90","\x05"),
	HX_HCSTRING("cascadeSplit","\x06","\xea","\x44","\x97"),
	HX_HCSTRING("data","\x2a","\x56","\x63","\x42"),
	HX_HCSTRING("V","\x56","\x00","\x00","\x00"),
	HX_HCSTRING("P","\x50","\x00","\x00","\x00"),
	HX_HCSTRING("VP","\x3a","\x4b","\x00","\x00"),
	HX_HCSTRING("frustumPlanes","\x99","\x03","\x66","\x33"),
	HX_HCSTRING("remove","\x44","\x9c","\x88","\x04"),
	HX_HCSTRING("buildMatrices","\xe8","\xe6","\xb3","\x61"),
	HX_HCSTRING("setCascade","\xb2","\xd8","\x18","\xa9"),
	HX_HCSTRING("updateViewFrustum","\xf4","\x2f","\xf7","\x16"),
	HX_HCSTRING("setCubeFace","\xf4","\x05","\x33","\xd5"),
	HX_HCSTRING("bias","\x79","\xea","\x16","\x41"),
	HX_HCSTRING("getCascadeData","\x88","\xb3","\xd4","\x2c"),
	HX_HCSTRING("right","\xdc","\x0b","\x64","\xe9"),
	HX_HCSTRING("up","\x5b","\x66","\x00","\x00"),
	HX_HCSTRING("look","\x5f","\xa6","\xb7","\x47"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	::String(null()) };

static void LampObject_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(LampObject_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(LampObject_obj::cascadeCount,"cascadeCount");
	HX_MARK_MEMBER_NAME(LampObject_obj::cascadeSplitFactor,"cascadeSplitFactor");
	HX_MARK_MEMBER_NAME(LampObject_obj::corners,"corners");
	HX_MARK_MEMBER_NAME(LampObject_obj::m,"m");
	HX_MARK_MEMBER_NAME(LampObject_obj::p1,"p1");
	HX_MARK_MEMBER_NAME(LampObject_obj::p2,"p2");
	HX_MARK_MEMBER_NAME(LampObject_obj::p3,"p3");
};

#ifdef HXCPP_VISIT_ALLOCS
static void LampObject_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(LampObject_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(LampObject_obj::cascadeCount,"cascadeCount");
	HX_VISIT_MEMBER_NAME(LampObject_obj::cascadeSplitFactor,"cascadeSplitFactor");
	HX_VISIT_MEMBER_NAME(LampObject_obj::corners,"corners");
	HX_VISIT_MEMBER_NAME(LampObject_obj::m,"m");
	HX_VISIT_MEMBER_NAME(LampObject_obj::p1,"p1");
	HX_VISIT_MEMBER_NAME(LampObject_obj::p2,"p2");
	HX_VISIT_MEMBER_NAME(LampObject_obj::p3,"p3");
};

#endif

hx::Class LampObject_obj::__mClass;

static ::String LampObject_obj_sStaticFields[] = {
	HX_HCSTRING("cascadeCount","\xfb","\x43","\x39","\x60"),
	HX_HCSTRING("cascadeSplitFactor","\x75","\x3f","\xf3","\x12"),
	HX_HCSTRING("corners","\xfe","\x9a","\x1a","\x63"),
	HX_HCSTRING("setCorners","\x7c","\xbf","\xf9","\xb5"),
	HX_HCSTRING("m","\x6d","\x00","\x00","\x00"),
	HX_HCSTRING("mix","\x9c","\x11","\x53","\x00"),
	HX_HCSTRING("p1","\xc1","\x61","\x00","\x00"),
	HX_HCSTRING("p2","\xc2","\x61","\x00","\x00"),
	HX_HCSTRING("p3","\xc3","\x61","\x00","\x00"),
	::String(null())
};

void LampObject_obj::__register()
{
	hx::Object *dummy = new LampObject_obj;
	LampObject_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("iron.object.LampObject","\xc0","\x56","\xcd","\x4d");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &LampObject_obj::__GetStatic;
	__mClass->mSetStaticField = &LampObject_obj::__SetStatic;
	__mClass->mMarkFunc = LampObject_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(LampObject_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(LampObject_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< LampObject_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = LampObject_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = LampObject_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = LampObject_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void LampObject_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_12_boot)
HXDLIN(  12)		cascadeCount = (int)1;
            	}
{
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_13_boot)
HXDLIN(  13)		cascadeSplitFactor = ((Float)0.8);
            	}
{
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_30_boot)
HXDLIN(  30)		corners = null();
            	}
{
            	HX_STACKFRAME(&_hx_pos_acb023f1fcb194c9_73_boot)
HXDLIN(  73)		m = ::iron::math::Mat4_obj::identity();
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_218_boot)
HXDLIN( 218)		p1 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_219_boot)
HXDLIN( 219)		p2 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
{
            	HX_GC_STACKFRAME(&_hx_pos_acb023f1fcb194c9_220_boot)
HXDLIN( 220)		p3 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
            	}
}

} // end namespace iron
} // end namespace object
