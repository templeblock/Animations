// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_Date
#include <Date.h>
#endif
#ifndef INCLUDED_List
#include <List.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_haxe_io_BytesBuffer
#include <haxe/io/BytesBuffer.h>
#endif
#ifndef INCLUDED_haxe_io_Error
#include <haxe/io/Error.h>
#endif
#ifndef INCLUDED_haxe_io_Input
#include <haxe/io/Input.h>
#endif
#ifndef INCLUDED_haxe_zip_ExtraField
#include <haxe/zip/ExtraField.h>
#endif
#ifndef INCLUDED_haxe_zip_InflateImpl
#include <haxe/zip/InflateImpl.h>
#endif
#ifndef INCLUDED_haxe_zip_Reader
#include <haxe/zip/Reader.h>
#endif
#ifndef INCLUDED_haxe_zip_Uncompress
#include <haxe/zip/Uncompress.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_7374f17556904b94_32_new,"haxe.zip.Reader","new",0xf101338a,"haxe.zip.Reader.new","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",32,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_35_readZipDate,"haxe.zip.Reader","readZipDate",0xa6a02623,"haxe.zip.Reader.readZipDate","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",35,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_47_readExtraFields,"haxe.zip.Reader","readExtraFields",0x48ea639d,"haxe.zip.Reader.readExtraFields","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",47,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_75_readEntryHeader,"haxe.zip.Reader","readEntryHeader",0x28765213,"haxe.zip.Reader.readEntryHeader","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",75,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_118_read,"haxe.zip.Reader","read",0xf2b0acec,"haxe.zip.Reader.read","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",118,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_190_readZip,"haxe.zip.Reader","readZip",0x2845d555,"haxe.zip.Reader.readZip","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",190,0x5ac39fe4)
HX_LOCAL_STACK_FRAME(_hx_pos_7374f17556904b94_195_unzip,"haxe.zip.Reader","unzip",0x282047d2,"haxe.zip.Reader.unzip","/Applications/blender.app/armsdk/Kha/Tools/haxe/std/haxe/zip/Reader.hx",195,0x5ac39fe4)
namespace haxe{
namespace zip{

void Reader_obj::__construct( ::haxe::io::Input i){
            	HX_STACKFRAME(&_hx_pos_7374f17556904b94_32_new)
HXDLIN(  32)		this->i = i;
            	}

Dynamic Reader_obj::__CreateEmpty() { return new Reader_obj; }

void *Reader_obj::_hx_vtable = 0;

Dynamic Reader_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Reader_obj > _hx_result = new Reader_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool Reader_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2836055e;
}

 ::Date Reader_obj::readZipDate(){
            	HX_GC_STACKFRAME(&_hx_pos_7374f17556904b94_35_readZipDate)
HXLINE(  36)		int t = this->i->readUInt16();
HXLINE(  37)		int hour = ((int)((int)t >> (int)(int)11) & (int)(int)31);
HXLINE(  38)		int min = ((int)((int)t >> (int)(int)5) & (int)(int)63);
HXLINE(  39)		int sec = ((int)t & (int)(int)31);
HXLINE(  40)		int d = this->i->readUInt16();
HXLINE(  41)		int year = ((int)d >> (int)(int)9);
HXLINE(  42)		int month = ((int)((int)d >> (int)(int)5) & (int)(int)15);
HXLINE(  43)		int day = ((int)d & (int)(int)31);
HXLINE(  44)		return  ::Date_obj::__alloc( HX_CTX ,(year + (int)1980),(month - (int)1),day,hour,min,((int)sec << (int)(int)1));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Reader_obj,readZipDate,return )

 ::List Reader_obj::readExtraFields(int length){
            	HX_GC_STACKFRAME(&_hx_pos_7374f17556904b94_47_readExtraFields)
HXLINE(  48)		 ::List fields =  ::List_obj::__alloc( HX_CTX );
HXLINE(  49)		while((length > (int)0)){
HXLINE(  50)			if ((length < (int)4)) {
HXLINE(  50)				HX_STACK_DO_THROW(HX_("Invalid extra fields data",18,88,a4,23));
            			}
HXLINE(  51)			int tag = this->i->readUInt16();
HXLINE(  52)			int len = this->i->readUInt16();
HXLINE(  53)			if ((length < len)) {
HXLINE(  53)				HX_STACK_DO_THROW(HX_("Invalid extra fields data",18,88,a4,23));
            			}
HXLINE(  54)			if ((tag == (int)28789)) {
HXLINE(  56)				int version = this->i->readByte();
HXLINE(  57)				if ((version != (int)1)) {
HXLINE(  58)					 ::haxe::io::BytesBuffer data =  ::haxe::io::BytesBuffer_obj::__alloc( HX_CTX );
HXLINE(  59)					data->b->push(version);
HXLINE(  60)					{
HXLINE(  60)						 ::haxe::io::Input src = this->i;
HXDLIN(  60)						 ::haxe::io::Bytes src1 = src->read((len - (int)1));
HXDLIN(  60)						::Array< unsigned char > b1 = data->b;
HXDLIN(  60)						::Array< unsigned char > b2 = src1->b;
HXDLIN(  60)						{
HXLINE(  60)							int _g1 = (int)0;
HXDLIN(  60)							int _g = src1->length;
HXDLIN(  60)							while((_g1 < _g)){
HXLINE(  60)								_g1 = (_g1 + (int)1);
HXDLIN(  60)								int i = (_g1 - (int)1);
HXDLIN(  60)								::Array< unsigned char > data1 = data->b;
HXDLIN(  60)								data1->push(b2->__get(i));
            							}
            						}
            					}
HXLINE(  61)					fields->add(::haxe::zip::ExtraField_obj::FUnknown(tag,data->getBytes()));
            				}
            				else {
HXLINE(  63)					int crc = this->i->readInt32();
HXLINE(  64)					 ::haxe::io::Input name = this->i;
HXDLIN(  64)					::String name1 = name->read((len - (int)5))->toString();
HXLINE(  65)					fields->add(::haxe::zip::ExtraField_obj::FInfoZipUnicodePath(name1,crc));
            				}
            			}
            			else {
HXLINE(  68)				fields->add(::haxe::zip::ExtraField_obj::FUnknown(tag,this->i->read(len)));
            			}
HXLINE(  70)			length = (length - ((int)4 + len));
            		}
HXLINE(  72)		return fields;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Reader_obj,readExtraFields,return )

 ::Dynamic Reader_obj::readEntryHeader(){
            	HX_STACKFRAME(&_hx_pos_7374f17556904b94_75_readEntryHeader)
HXLINE(  76)		 ::haxe::io::Input i = this->i;
HXLINE(  77)		int h = i->readInt32();
HXLINE(  78)		bool _hx_tmp;
HXDLIN(  78)		if ((h != (int)33639248)) {
HXLINE(  78)			_hx_tmp = (h == (int)101010256);
            		}
            		else {
HXLINE(  78)			_hx_tmp = true;
            		}
HXDLIN(  78)		if (_hx_tmp) {
HXLINE(  79)			return null();
            		}
HXLINE(  80)		if ((h != (int)67324752)) {
HXLINE(  81)			HX_STACK_DO_THROW(HX_("Invalid Zip Data",72,da,ff,99));
            		}
HXLINE(  82)		int version = i->readUInt16();
HXLINE(  83)		int flags = i->readUInt16();
HXLINE(  84)		bool utf8 = (((int)flags & (int)(int)2048) != (int)0);
HXLINE(  85)		if ((((int)flags & (int)(int)63473) != (int)0)) {
HXLINE(  86)			HX_STACK_DO_THROW((HX_("Unsupported flags ",24,93,26,a4) + flags));
            		}
HXLINE(  87)		int compression = i->readUInt16();
HXLINE(  88)		bool compressed = (compression != (int)0);
HXLINE(  89)		bool _hx_tmp1;
HXDLIN(  89)		if (compressed) {
HXLINE(  89)			_hx_tmp1 = (compression != (int)8);
            		}
            		else {
HXLINE(  89)			_hx_tmp1 = false;
            		}
HXDLIN(  89)		if (_hx_tmp1) {
HXLINE(  90)			HX_STACK_DO_THROW((HX_("Unsupported compression ",65,94,24,90) + compression));
            		}
HXLINE(  91)		 ::Date mtime = this->readZipDate();
HXLINE(  92)		 ::Dynamic crc32 = i->readInt32();
HXLINE(  93)		int csize = i->readInt32();
HXLINE(  94)		int usize = i->readInt32();
HXLINE(  95)		int fnamelen = i->readInt16();
HXLINE(  96)		int elen = i->readInt16();
HXLINE(  97)		::String fname = i->readString(fnamelen);
HXLINE(  98)		 ::List fields = this->readExtraFields(elen);
HXLINE(  99)		if (utf8) {
HXLINE( 100)			fields->push(::haxe::zip::ExtraField_obj::FUtf8_dyn());
            		}
HXLINE( 101)		 ::haxe::io::Bytes data = null();
HXLINE( 104)		if ((((int)flags & (int)(int)8) != (int)0)) {
HXLINE( 105)			crc32 = null();
            		}
HXLINE( 106)		return  ::Dynamic(hx::Anon_obj::Create(8)
            			->setFixed(0,HX_("dataSize",0b,80,c7,8b),csize)
            			->setFixed(1,HX_("data",2a,56,63,42),data)
            			->setFixed(2,HX_("crc32",73,0c,51,4c),crc32)
            			->setFixed(3,HX_("fileName",e7,5a,43,62),fname)
            			->setFixed(4,HX_("fileSize",5d,89,97,65),usize)
            			->setFixed(5,HX_("fileTime",a9,b4,40,66),mtime)
            			->setFixed(6,HX_("compressed",81,4c,da,67),compressed)
            			->setFixed(7,HX_("extraFields",29,e9,47,7f),fields));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Reader_obj,readEntryHeader,return )

 ::List Reader_obj::read(){
            	HX_GC_STACKFRAME(&_hx_pos_7374f17556904b94_118_read)
HXLINE( 119)		 ::List l =  ::List_obj::__alloc( HX_CTX );
HXLINE( 120)		 ::Dynamic buf = null();
HXLINE( 121)		 ::haxe::io::Bytes tmp = null();
HXLINE( 122)		while(true){
HXLINE( 123)			 ::Dynamic e = this->readEntryHeader();
HXLINE( 124)			if (hx::IsNull( e )) {
HXLINE( 125)				goto _hx_goto_6;
            			}
HXLINE( 127)			if (hx::IsNull( e->__Field(HX_("crc32",73,0c,51,4c),hx::paccDynamic) )) {
HXLINE( 128)				if (( (bool)(e->__Field(HX_("compressed",81,4c,da,67),hx::paccDynamic)) )) {
HXLINE( 160)					int bufSize = (int)65536;
HXLINE( 161)					if (hx::IsNull( tmp )) {
HXLINE( 162)						tmp = ::haxe::io::Bytes_obj::alloc(bufSize);
            					}
HXLINE( 163)					 ::haxe::io::BytesBuffer out =  ::haxe::io::BytesBuffer_obj::__alloc( HX_CTX );
HXLINE( 164)					 ::haxe::zip::InflateImpl z =  ::haxe::zip::InflateImpl_obj::__alloc( HX_CTX ,this->i,false,false);
HXLINE( 165)					while(true){
HXLINE( 166)						int n = z->readBytes(tmp,(int)0,bufSize);
HXLINE( 167)						{
HXLINE( 167)							bool _hx_tmp;
HXDLIN( 167)							if ((n >= (int)0)) {
HXLINE( 167)								_hx_tmp = (n > tmp->length);
            							}
            							else {
HXLINE( 167)								_hx_tmp = true;
            							}
HXDLIN( 167)							if (_hx_tmp) {
HXLINE( 167)								HX_STACK_DO_THROW(::haxe::io::Error_obj::OutsideBounds_dyn());
            							}
HXDLIN( 167)							::Array< unsigned char > b1 = out->b;
HXDLIN( 167)							::Array< unsigned char > b2 = tmp->b;
HXDLIN( 167)							{
HXLINE( 167)								int _g1 = (int)0;
HXDLIN( 167)								int _g = n;
HXDLIN( 167)								while((_g1 < _g)){
HXLINE( 167)									_g1 = (_g1 + (int)1);
HXDLIN( 167)									int i = (_g1 - (int)1);
HXDLIN( 167)									::Array< unsigned char > out1 = out->b;
HXDLIN( 167)									out1->push(b2->__get(i));
            								}
            							}
            						}
HXLINE( 168)						if ((n < bufSize)) {
HXLINE( 169)							goto _hx_goto_7;
            						}
            					}
            					_hx_goto_7:;
HXLINE( 171)					e->__SetField(HX_("data",2a,56,63,42),out->getBytes(),hx::paccDynamic);
            				}
            				else {
HXLINE( 174)					e->__SetField(HX_("data",2a,56,63,42),this->i->read(( (int)(e->__Field(HX_("dataSize",0b,80,c7,8b),hx::paccDynamic)) )),hx::paccDynamic);
            				}
HXLINE( 175)				e->__SetField(HX_("crc32",73,0c,51,4c),this->i->readInt32(),hx::paccDynamic);
HXLINE( 176)				if (hx::IsEq( e->__Field(HX_("crc32",73,0c,51,4c),hx::paccDynamic),(int)134695760 )) {
HXLINE( 177)					e->__SetField(HX_("crc32",73,0c,51,4c),this->i->readInt32(),hx::paccDynamic);
            				}
HXLINE( 178)				e->__SetField(HX_("dataSize",0b,80,c7,8b),this->i->readInt32(),hx::paccDynamic);
HXLINE( 179)				e->__SetField(HX_("fileSize",5d,89,97,65),this->i->readInt32(),hx::paccDynamic);
HXLINE( 181)				e->__SetField(HX_("dataSize",0b,80,c7,8b),( (int)(e->__Field(HX_("fileSize",5d,89,97,65),hx::paccDynamic)) ),hx::paccDynamic);
HXLINE( 182)				e->__SetField(HX_("compressed",81,4c,da,67),false,hx::paccDynamic);
            			}
            			else {
HXLINE( 184)				e->__SetField(HX_("data",2a,56,63,42),this->i->read(( (int)(e->__Field(HX_("dataSize",0b,80,c7,8b),hx::paccDynamic)) )),hx::paccDynamic);
            			}
HXLINE( 185)			l->add(e);
            		}
            		_hx_goto_6:;
HXLINE( 187)		return l;
            	}


HX_DEFINE_DYNAMIC_FUNC0(Reader_obj,read,return )

 ::List Reader_obj::readZip( ::haxe::io::Input i){
            	HX_GC_STACKFRAME(&_hx_pos_7374f17556904b94_190_readZip)
HXLINE( 191)		 ::haxe::zip::Reader r =  ::haxe::zip::Reader_obj::__alloc( HX_CTX ,i);
HXLINE( 192)		return r->read();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Reader_obj,readZip,return )

 ::haxe::io::Bytes Reader_obj::unzip( ::Dynamic f){
            	HX_GC_STACKFRAME(&_hx_pos_7374f17556904b94_195_unzip)
HXLINE( 196)		if (!(( (bool)(f->__Field(HX_("compressed",81,4c,da,67),hx::paccDynamic)) ))) {
HXLINE( 197)			return ( ( ::haxe::io::Bytes)(f->__Field(HX_("data",2a,56,63,42),hx::paccDynamic)) );
            		}
HXLINE( 198)		 ::haxe::zip::Uncompress c =  ::haxe::zip::Uncompress_obj::__alloc( HX_CTX ,(int)-15);
HXLINE( 199)		 ::haxe::io::Bytes s = ::haxe::io::Bytes_obj::alloc(( (int)(f->__Field(HX_("fileSize",5d,89,97,65),hx::paccDynamic)) ));
HXLINE( 200)		 ::Dynamic r = c->execute(( ( ::haxe::io::Bytes)(f->__Field(HX_("data",2a,56,63,42),hx::paccDynamic)) ),(int)0,s,(int)0);
HXLINE( 201)		c->close();
HXLINE( 202)		bool _hx_tmp;
HXDLIN( 202)		bool _hx_tmp1;
HXDLIN( 202)		if (!(!(( (bool)(r->__Field(HX_("done",82,f0,6d,42),hx::paccDynamic)) )))) {
HXLINE( 202)			_hx_tmp1 = (( (int)(r->__Field(HX_("read",56,4b,a7,4b),hx::paccDynamic)) ) != ( ( ::haxe::io::Bytes)(f->__Field(HX_("data",2a,56,63,42),hx::paccDynamic)) )->length);
            		}
            		else {
HXLINE( 202)			_hx_tmp1 = true;
            		}
HXDLIN( 202)		if (!(_hx_tmp1)) {
HXLINE( 202)			_hx_tmp = (( (int)(r->__Field(HX_("write",df,6c,59,d0),hx::paccDynamic)) ) != ( (int)(f->__Field(HX_("fileSize",5d,89,97,65),hx::paccDynamic)) ));
            		}
            		else {
HXLINE( 202)			_hx_tmp = true;
            		}
HXDLIN( 202)		if (_hx_tmp) {
HXLINE( 203)			HX_STACK_DO_THROW((HX_("Invalid compressed data for ",37,5a,72,7b) + ( (::String)(f->__Field(HX_("fileName",e7,5a,43,62),hx::paccDynamic)) )));
            		}
HXLINE( 204)		f->__SetField(HX_("compressed",81,4c,da,67),false,hx::paccDynamic);
HXLINE( 205)		f->__SetField(HX_("dataSize",0b,80,c7,8b),( (int)(f->__Field(HX_("fileSize",5d,89,97,65),hx::paccDynamic)) ),hx::paccDynamic);
HXLINE( 206)		f->__SetField(HX_("data",2a,56,63,42),s,hx::paccDynamic);
HXLINE( 207)		return ( ( ::haxe::io::Bytes)(f->__Field(HX_("data",2a,56,63,42),hx::paccDynamic)) );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Reader_obj,unzip,return )


hx::ObjectPtr< Reader_obj > Reader_obj::__new( ::haxe::io::Input i) {
	hx::ObjectPtr< Reader_obj > __this = new Reader_obj();
	__this->__construct(i);
	return __this;
}

hx::ObjectPtr< Reader_obj > Reader_obj::__alloc(hx::Ctx *_hx_ctx, ::haxe::io::Input i) {
	Reader_obj *__this = (Reader_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Reader_obj), true, "haxe.zip.Reader"));
	*(void **)__this = Reader_obj::_hx_vtable;
	__this->__construct(i);
	return __this;
}

Reader_obj::Reader_obj()
{
}

void Reader_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Reader);
	HX_MARK_MEMBER_NAME(i,"i");
	HX_MARK_END_CLASS();
}

void Reader_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(i,"i");
}

hx::Val Reader_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"i") ) { return hx::Val( i ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"read") ) { return hx::Val( read_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"readZipDate") ) { return hx::Val( readZipDate_dyn() ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"readExtraFields") ) { return hx::Val( readExtraFields_dyn() ); }
		if (HX_FIELD_EQ(inName,"readEntryHeader") ) { return hx::Val( readEntryHeader_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Reader_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"unzip") ) { outValue = unzip_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"readZip") ) { outValue = readZip_dyn(); return true; }
	}
	return false;
}

hx::Val Reader_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 1:
		if (HX_FIELD_EQ(inName,"i") ) { i=inValue.Cast<  ::haxe::io::Input >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Reader_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("i","\x69","\x00","\x00","\x00"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Reader_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::haxe::io::Input*/ ,(int)offsetof(Reader_obj,i),HX_HCSTRING("i","\x69","\x00","\x00","\x00")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Reader_obj_sStaticStorageInfo = 0;
#endif

static ::String Reader_obj_sMemberFields[] = {
	HX_HCSTRING("i","\x69","\x00","\x00","\x00"),
	HX_HCSTRING("readZipDate","\xf9","\x88","\xbc","\xc9"),
	HX_HCSTRING("readExtraFields","\x73","\xe9","\x9f","\xa6"),
	HX_HCSTRING("readEntryHeader","\xe9","\xd7","\x2b","\x86"),
	HX_HCSTRING("read","\x56","\x4b","\xa7","\x4b"),
	::String(null()) };

static void Reader_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Reader_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Reader_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Reader_obj::__mClass,"__mClass");
};

#endif

hx::Class Reader_obj::__mClass;

static ::String Reader_obj_sStaticFields[] = {
	HX_HCSTRING("readZip","\x2b","\x95","\xd6","\x02"),
	HX_HCSTRING("unzip","\x28","\x46","\xf4","\xa6"),
	::String(null())
};

void Reader_obj::__register()
{
	hx::Object *dummy = new Reader_obj;
	Reader_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("haxe.zip.Reader","\x98","\x66","\x32","\xed");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Reader_obj::__GetStatic;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Reader_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Reader_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Reader_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Reader_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Reader_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Reader_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Reader_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace haxe
} // end namespace zip
