// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_c5728fd05c542abe
#define INCLUDED_c5728fd05c542abe
#include "cpp_float32array.h"
#endif
#ifndef INCLUDED_7d028c26efabce49
#define INCLUDED_7d028c26efabce49
#include "cpp_uint32array.h"
#endif
#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_armory_trait_ConvexBreaker
#include <armory/trait/ConvexBreaker.h>
#endif
#ifndef INCLUDED_armory_trait_ConvexHull
#include <armory/trait/ConvexHull.h>
#endif
#ifndef INCLUDED_armory_trait_CutResult
#include <armory/trait/CutResult.h>
#endif
#ifndef INCLUDED_armory_trait_Face3
#include <armory/trait/Face3.h>
#endif
#ifndef INCLUDED_armory_trait_Line3
#include <armory/trait/Line3.h>
#endif
#ifndef INCLUDED_armory_trait_Plane
#include <armory/trait/Plane.h>
#endif
#ifndef INCLUDED_armory_trait_UserData
#include <armory/trait/UserData.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_haxe_ds_ObjectMap
#include <haxe/ds/ObjectMap.h>
#endif
#ifndef INCLUDED_iron_Scene
#include <iron/Scene.h>
#endif
#ifndef INCLUDED_iron_data_Data
#include <iron/data/Data.h>
#endif
#ifndef INCLUDED_iron_data_Geometry
#include <iron/data/Geometry.h>
#endif
#ifndef INCLUDED_iron_data_MaterialData
#include <iron/data/MaterialData.h>
#endif
#ifndef INCLUDED_iron_data_MeshData
#include <iron/data/MeshData.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Quat
#include <iron/math/Quat.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <iron/math/Vec4.h>
#endif
#ifndef INCLUDED_iron_object_MeshObject
#include <iron/object/MeshObject.h>
#endif
#ifndef INCLUDED_iron_object_Object
#include <iron/object/Object.h>
#endif
#ifndef INCLUDED_iron_object_Transform
#include <iron/object/Transform.h>
#endif
#ifndef INCLUDED_kha_arrays_Float32ArrayPrivate
#include <kha/arrays/Float32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_arrays_Uint32ArrayPrivate
#include <kha/arrays/Uint32ArrayPrivate.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix4
#include <kha/math/FastMatrix4.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_a7abec19ed523c93_101_new,"armory.trait.ConvexBreaker","new",0x63bc1da3,"armory.trait.ConvexBreaker.new","armory/trait/PhysicsBreak.hx",101,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_153_initBreakableObject,"armory.trait.ConvexBreaker","initBreakableObject",0x15b8bb8b,"armory.trait.ConvexBreaker.initBreakableObject","armory/trait/PhysicsBreak.hx",153,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_119_initBreakableObject,"armory.trait.ConvexBreaker","initBreakableObject",0x15b8bb8b,"armory.trait.ConvexBreaker.initBreakableObject","armory/trait/PhysicsBreak.hx",119,0x7f52e3b0)
static const int _hx_array_data_e2161031_8[] = {
	(int)0,
};
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_190_subdivideByImpact,"armory.trait.ConvexBreaker","subdivideByImpact",0xe653ec99,"armory.trait.ConvexBreaker.subdivideByImpact","armory/trait/PhysicsBreak.hx",190,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_181_subdivideByImpact,"armory.trait.ConvexBreaker","subdivideByImpact",0xe653ec99,"armory.trait.ConvexBreaker.subdivideByImpact","armory/trait/PhysicsBreak.hx",181,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_236_transformFreeVector,"armory.trait.ConvexBreaker","transformFreeVector",0x2a137e5e,"armory.trait.ConvexBreaker.transformFreeVector","armory/trait/PhysicsBreak.hx",236,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_246_transformFreeVectorInverse,"armory.trait.ConvexBreaker","transformFreeVectorInverse",0x6e409cf2,"armory.trait.ConvexBreaker.transformFreeVectorInverse","armory/trait/PhysicsBreak.hx",246,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_256_transformTiedVectorInverse,"armory.trait.ConvexBreaker","transformTiedVectorInverse",0xd437538a,"armory.trait.ConvexBreaker.transformTiedVectorInverse","armory/trait/PhysicsBreak.hx",256,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_266_transformPlaneToLocalSpace,"armory.trait.ConvexBreaker","transformPlaneToLocalSpace",0xbbb47943,"armory.trait.ConvexBreaker.transformPlaneToLocalSpace","armory/trait/PhysicsBreak.hx",266,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_282_cutByPlane,"armory.trait.ConvexBreaker","cutByPlane",0x9f8ef4c0,"armory.trait.ConvexBreaker.cutByPlane","armory/trait/PhysicsBreak.hx",282,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_500_makeMeshData,"armory.trait.ConvexBreaker","makeMeshData",0xba61cd22,"armory.trait.ConvexBreaker.makeMeshData","armory/trait/PhysicsBreak.hx",500,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_483_makeMeshData,"armory.trait.ConvexBreaker","makeMeshData",0xba61cd22,"armory.trait.ConvexBreaker.makeMeshData","armory/trait/PhysicsBreak.hx",483,0x7f52e3b0)
HX_LOCAL_STACK_FRAME(_hx_pos_a7abec19ed523c93_482_boot,"armory.trait.ConvexBreaker","boot",0xd8f6d18f,"armory.trait.ConvexBreaker.boot","armory/trait/PhysicsBreak.hx",482,0x7f52e3b0)
namespace armory{
namespace trait{

void ConvexBreaker_obj::__construct(hx::Null< Float >  __o_minSizeForBreak,hx::Null< Float >  __o_smallDelta){
Float minSizeForBreak = __o_minSizeForBreak.Default(((Float)1.4));
Float smallDelta = __o_smallDelta.Default(((Float)0.0001));
            	HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_101_new)
HXLINE( 102)		this->minSizeForBreak = minSizeForBreak;
HXLINE( 103)		this->smallDelta = smallDelta;
HXLINE( 104)		this->tempLine =  ::armory::trait::Line3_obj::__alloc( HX_CTX );
HXLINE( 105)		this->tempPlane =  ::armory::trait::Plane_obj::__alloc( HX_CTX );
HXLINE( 106)		this->tempPlane2 =  ::armory::trait::Plane_obj::__alloc( HX_CTX );
HXLINE( 107)		this->tempCM1 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 108)		this->tempCM2 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 109)		this->tempVec4 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 110)		this->tempVec42 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 111)		this->tempVec43 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 112)		this->tempCutResult =  ::armory::trait::CutResult_obj::__alloc( HX_CTX );
HXLINE( 113)		this->segments = ::Array_obj< bool >::__new();
HXLINE( 114)		int n = (int)900;
HXLINE( 115)		{
HXLINE( 115)			int _g1 = (int)0;
HXDLIN( 115)			int _g = n;
HXDLIN( 115)			while((_g1 < _g)){
HXLINE( 115)				_g1 = (_g1 + (int)1);
HXDLIN( 115)				int i = (_g1 - (int)1);
HXDLIN( 115)				this->segments->push(false);
            			}
            		}
HXLINE( 116)		this->userDataMap =  ::haxe::ds::ObjectMap_obj::__alloc( HX_CTX );
            	}

Dynamic ConvexBreaker_obj::__CreateEmpty() { return new ConvexBreaker_obj; }

void *ConvexBreaker_obj::_hx_vtable = 0;

Dynamic ConvexBreaker_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ConvexBreaker_obj > _hx_result = new ConvexBreaker_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool ConvexBreaker_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x45a066b1;
}

void ConvexBreaker_obj::initBreakableObject( ::iron::object::MeshObject object,Float mass, ::iron::math::Vec4 velocity, ::iron::math::Vec4 angularVelocity,bool breakable){
            		HX_BEGIN_LOCAL_FUNC_S4(hx::LocalFunc,_hx_Closure_0,::Array< ::Dynamic>,vertices,::Array< int >,i2, ::haxe::ds::IntMap,map,::Array< ::Dynamic>,verts) HXARGC(1)
            		int _hx_run(int fi){
            			HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_153_initBreakableObject)
HXLINE( 154)			 ::Dynamic val = map->get(fi);
HXLINE( 155)			if (hx::IsNull( val )) {
HXLINE( 156)				verts->push(vertices->__get(fi).StaticCast<  ::iron::math::Vec4 >());
HXLINE( 157)				map->set(fi,i2->__get((int)0));
HXLINE( 158)				i2[(int)0]++;
HXLINE( 159)				return (i2->__get((int)0) - (int)1);
            			}
            			else {
HXLINE( 161)				return val;
            			}
HXLINE( 155)			return (int)0;
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_119_initBreakableObject)
HXLINE( 120)		 ::kha::arrays::Float32ArrayPrivate ar = object->data->geom->positions;
HXLINE( 122)		 ::iron::math::Vec4 sc = object->transform->scale;
HXLINE( 123)		::Array< ::Dynamic> vertices = ::Array_obj< ::Dynamic>::__new();
HXLINE( 124)		{
HXLINE( 124)			int _g1 = (int)0;
HXDLIN( 124)			int _g = ::Std_obj::_hx_int(((Float)ar->self.length() / (Float)(int)3));
HXDLIN( 124)			while((_g1 < _g)){
HXLINE( 124)				_g1 = (_g1 + (int)1);
HXDLIN( 124)				int i = (_g1 - (int)1);
HXLINE( 126)				 float32array ar1 = ar->self;
HXDLIN( 126)				float _hx_tmp = ar1.get((i * (int)3));
HXDLIN( 126)				float _hx_tmp1 = (_hx_tmp * sc->x);
HXDLIN( 126)				 float32array ar2 = ar->self;
HXDLIN( 126)				float _hx_tmp2 = ar2.get(((i * (int)3) + (int)1));
HXDLIN( 126)				float _hx_tmp3 = (_hx_tmp2 * sc->y);
HXDLIN( 126)				 float32array ar3 = ar->self;
HXDLIN( 126)				float _hx_tmp4 = ar3.get(((i * (int)3) + (int)2));
HXDLIN( 126)				vertices->push( ::iron::math::Vec4_obj::__alloc( HX_CTX ,_hx_tmp1,_hx_tmp3,(_hx_tmp4 * sc->z),(int)0));
            			}
            		}
HXLINE( 129)		 ::kha::arrays::Uint32ArrayPrivate ind = object->data->geom->indices->__get((int)0).StaticCast<  ::kha::arrays::Uint32ArrayPrivate >();
HXLINE( 130)		::Array< ::Dynamic> faces = ::Array_obj< ::Dynamic>::__new();
HXLINE( 131)		{
HXLINE( 131)			int _g11 = (int)0;
HXDLIN( 131)			int _g2 = ::Std_obj::_hx_int(((Float)ind->self.length() / (Float)(int)3));
HXDLIN( 131)			while((_g11 < _g2)){
HXLINE( 131)				_g11 = (_g11 + (int)1);
HXDLIN( 131)				int i1 = (_g11 - (int)1);
HXLINE( 132)				 uint32array ind1 = ind->self;
HXDLIN( 132)				int a = ind1.get((i1 * (int)3));
HXLINE( 133)				 uint32array ind2 = ind->self;
HXDLIN( 133)				int b = ind2.get(((i1 * (int)3) + (int)1));
HXLINE( 134)				 uint32array ind3 = ind->self;
HXDLIN( 134)				int c = ind3.get(((i1 * (int)3) + (int)2));
HXLINE( 136)				{
HXLINE( 136)					int _g21 = (int)0;
HXDLIN( 136)					while((_g21 < faces->length)){
HXLINE( 136)						 ::armory::trait::Face3 f = faces->__get(_g21).StaticCast<  ::armory::trait::Face3 >();
HXDLIN( 136)						_g21 = (_g21 + (int)1);
HXLINE( 137)						 ::iron::math::Vec4 _this = vertices->__get(a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 137)						 ::iron::math::Vec4 v = vertices->__get(f->a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 137)						bool _hx_tmp5;
HXDLIN( 137)						bool _hx_tmp6;
HXDLIN( 137)						if ((_this->x == v->x)) {
HXLINE( 137)							_hx_tmp6 = (_this->y == v->y);
            						}
            						else {
HXLINE( 137)							_hx_tmp6 = false;
            						}
HXDLIN( 137)						if (_hx_tmp6) {
HXLINE( 137)							_hx_tmp5 = (_this->z == v->z);
            						}
            						else {
HXLINE( 137)							_hx_tmp5 = false;
            						}
HXDLIN( 137)						if (_hx_tmp5) {
HXLINE( 137)							a = f->a;
            						}
            						else {
HXLINE( 138)							 ::iron::math::Vec4 _this1 = vertices->__get(a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 138)							 ::iron::math::Vec4 v1 = vertices->__get(f->b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 138)							bool _hx_tmp7;
HXDLIN( 138)							bool _hx_tmp8;
HXDLIN( 138)							if ((_this1->x == v1->x)) {
HXLINE( 138)								_hx_tmp8 = (_this1->y == v1->y);
            							}
            							else {
HXLINE( 138)								_hx_tmp8 = false;
            							}
HXDLIN( 138)							if (_hx_tmp8) {
HXLINE( 138)								_hx_tmp7 = (_this1->z == v1->z);
            							}
            							else {
HXLINE( 138)								_hx_tmp7 = false;
            							}
HXDLIN( 138)							if (_hx_tmp7) {
HXLINE( 138)								a = f->b;
            							}
            							else {
HXLINE( 139)								 ::iron::math::Vec4 _this2 = vertices->__get(a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 139)								 ::iron::math::Vec4 v2 = vertices->__get(f->c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 139)								bool _hx_tmp9;
HXDLIN( 139)								bool _hx_tmp10;
HXDLIN( 139)								if ((_this2->x == v2->x)) {
HXLINE( 139)									_hx_tmp10 = (_this2->y == v2->y);
            								}
            								else {
HXLINE( 139)									_hx_tmp10 = false;
            								}
HXDLIN( 139)								if (_hx_tmp10) {
HXLINE( 139)									_hx_tmp9 = (_this2->z == v2->z);
            								}
            								else {
HXLINE( 139)									_hx_tmp9 = false;
            								}
HXDLIN( 139)								if (_hx_tmp9) {
HXLINE( 139)									a = f->c;
            								}
            							}
            						}
HXLINE( 140)						 ::iron::math::Vec4 _this3 = vertices->__get(b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 140)						 ::iron::math::Vec4 v3 = vertices->__get(f->a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 140)						bool _hx_tmp11;
HXDLIN( 140)						bool _hx_tmp12;
HXDLIN( 140)						if ((_this3->x == v3->x)) {
HXLINE( 140)							_hx_tmp12 = (_this3->y == v3->y);
            						}
            						else {
HXLINE( 140)							_hx_tmp12 = false;
            						}
HXDLIN( 140)						if (_hx_tmp12) {
HXLINE( 140)							_hx_tmp11 = (_this3->z == v3->z);
            						}
            						else {
HXLINE( 140)							_hx_tmp11 = false;
            						}
HXDLIN( 140)						if (_hx_tmp11) {
HXLINE( 140)							b = f->a;
            						}
            						else {
HXLINE( 141)							 ::iron::math::Vec4 _this4 = vertices->__get(b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 141)							 ::iron::math::Vec4 v4 = vertices->__get(f->b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 141)							bool _hx_tmp13;
HXDLIN( 141)							bool _hx_tmp14;
HXDLIN( 141)							if ((_this4->x == v4->x)) {
HXLINE( 141)								_hx_tmp14 = (_this4->y == v4->y);
            							}
            							else {
HXLINE( 141)								_hx_tmp14 = false;
            							}
HXDLIN( 141)							if (_hx_tmp14) {
HXLINE( 141)								_hx_tmp13 = (_this4->z == v4->z);
            							}
            							else {
HXLINE( 141)								_hx_tmp13 = false;
            							}
HXDLIN( 141)							if (_hx_tmp13) {
HXLINE( 141)								b = f->b;
            							}
            							else {
HXLINE( 142)								 ::iron::math::Vec4 _this5 = vertices->__get(b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 142)								 ::iron::math::Vec4 v5 = vertices->__get(f->c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 142)								bool _hx_tmp15;
HXDLIN( 142)								bool _hx_tmp16;
HXDLIN( 142)								if ((_this5->x == v5->x)) {
HXLINE( 142)									_hx_tmp16 = (_this5->y == v5->y);
            								}
            								else {
HXLINE( 142)									_hx_tmp16 = false;
            								}
HXDLIN( 142)								if (_hx_tmp16) {
HXLINE( 142)									_hx_tmp15 = (_this5->z == v5->z);
            								}
            								else {
HXLINE( 142)									_hx_tmp15 = false;
            								}
HXDLIN( 142)								if (_hx_tmp15) {
HXLINE( 142)									b = f->c;
            								}
            							}
            						}
HXLINE( 143)						 ::iron::math::Vec4 _this6 = vertices->__get(c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 143)						 ::iron::math::Vec4 v6 = vertices->__get(f->a).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 143)						bool _hx_tmp17;
HXDLIN( 143)						bool _hx_tmp18;
HXDLIN( 143)						if ((_this6->x == v6->x)) {
HXLINE( 143)							_hx_tmp18 = (_this6->y == v6->y);
            						}
            						else {
HXLINE( 143)							_hx_tmp18 = false;
            						}
HXDLIN( 143)						if (_hx_tmp18) {
HXLINE( 143)							_hx_tmp17 = (_this6->z == v6->z);
            						}
            						else {
HXLINE( 143)							_hx_tmp17 = false;
            						}
HXDLIN( 143)						if (_hx_tmp17) {
HXLINE( 143)							c = f->a;
            						}
            						else {
HXLINE( 144)							 ::iron::math::Vec4 _this7 = vertices->__get(c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 144)							 ::iron::math::Vec4 v7 = vertices->__get(f->b).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 144)							bool _hx_tmp19;
HXDLIN( 144)							bool _hx_tmp20;
HXDLIN( 144)							if ((_this7->x == v7->x)) {
HXLINE( 144)								_hx_tmp20 = (_this7->y == v7->y);
            							}
            							else {
HXLINE( 144)								_hx_tmp20 = false;
            							}
HXDLIN( 144)							if (_hx_tmp20) {
HXLINE( 144)								_hx_tmp19 = (_this7->z == v7->z);
            							}
            							else {
HXLINE( 144)								_hx_tmp19 = false;
            							}
HXDLIN( 144)							if (_hx_tmp19) {
HXLINE( 144)								c = f->b;
            							}
            							else {
HXLINE( 145)								 ::iron::math::Vec4 _this8 = vertices->__get(c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 145)								 ::iron::math::Vec4 v8 = vertices->__get(f->c).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 145)								bool _hx_tmp21;
HXDLIN( 145)								bool _hx_tmp22;
HXDLIN( 145)								if ((_this8->x == v8->x)) {
HXLINE( 145)									_hx_tmp22 = (_this8->y == v8->y);
            								}
            								else {
HXLINE( 145)									_hx_tmp22 = false;
            								}
HXDLIN( 145)								if (_hx_tmp22) {
HXLINE( 145)									_hx_tmp21 = (_this8->z == v8->z);
            								}
            								else {
HXLINE( 145)									_hx_tmp21 = false;
            								}
HXDLIN( 145)								if (_hx_tmp21) {
HXLINE( 145)									c = f->c;
            								}
            							}
            						}
            					}
            				}
HXLINE( 147)				faces->push( ::armory::trait::Face3_obj::__alloc( HX_CTX ,a,b,c));
            			}
            		}
HXLINE( 150)		::Array< ::Dynamic> verts = ::Array_obj< ::Dynamic>::__new();
HXLINE( 151)		 ::haxe::ds::IntMap map =  ::haxe::ds::IntMap_obj::__alloc( HX_CTX );
HXLINE( 152)		::Array< int > i2 = ::Array_obj< int >::fromData( _hx_array_data_e2161031_8,1);
HXLINE( 153)		 ::Dynamic orderVert =  ::Dynamic(new _hx_Closure_0(vertices,i2,map,verts));
HXLINE( 163)		{
HXLINE( 163)			int _g3 = (int)0;
HXDLIN( 163)			while((_g3 < faces->length)){
HXLINE( 163)				 ::armory::trait::Face3 f1 = faces->__get(_g3).StaticCast<  ::armory::trait::Face3 >();
HXDLIN( 163)				_g3 = (_g3 + (int)1);
HXLINE( 164)				f1->a = ( (int)(orderVert(f1->a)) );
HXLINE( 165)				f1->b = ( (int)(orderVert(f1->b)) );
HXLINE( 166)				f1->c = ( (int)(orderVert(f1->c)) );
            			}
            		}
HXLINE( 169)		 ::armory::trait::UserData userData =  ::armory::trait::UserData_obj::__alloc( HX_CTX );
HXLINE( 170)		userData->mass = mass;
HXLINE( 171)		userData->velocity = velocity->clone();
HXLINE( 172)		userData->angularVelocity = angularVelocity->clone();
HXLINE( 173)		userData->breakable = breakable;
HXLINE( 174)		userData->vertices = verts;
HXLINE( 175)		userData->faces = faces;
HXLINE( 176)		this->userDataMap->set(object,userData);
            	}


HX_DEFINE_DYNAMIC_FUNC5(ConvexBreaker_obj,initBreakableObject,(void))

::Array< ::Dynamic> ConvexBreaker_obj::subdivideByImpact( ::iron::object::MeshObject object, ::iron::math::Vec4 pointOfImpact, ::iron::math::Vec4 normal,int maxRadialIterations,int maxRandomIterations){
            		HX_BEGIN_LOCAL_FUNC_S9(hx::LocalFunc,_hx_Closure_0, ::iron::math::Vec4,normal, ::armory::trait::ConvexBreaker,_gthis,int,maxTotalIterations, ::armory::trait::ConvexBreaker,scope,int,maxRadialIterations, ::iron::math::Vec4,pointOfImpact,::Array< ::Dynamic>,debris, ::iron::object::MeshObject,object,::Array< ::Dynamic>,subdivideRadial) HXARGC(4)
            		void _hx_run( ::iron::object::MeshObject subObject,Float startAngle,Float endAngle,int numIterations){
            			HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_190_subdivideByImpact)
HXLINE( 192)			bool _hx_tmp;
HXDLIN( 192)			Float _hx_tmp1 = ::Math_obj::random();
HXDLIN( 192)			if (!((_hx_tmp1 < (numIterations * ((Float)0.05))))) {
HXLINE( 192)				_hx_tmp = (numIterations > maxTotalIterations);
            			}
            			else {
HXLINE( 192)				_hx_tmp = true;
            			}
HXDLIN( 192)			if (_hx_tmp) {
HXLINE( 193)				debris->push(subObject);
HXLINE( 194)				return;
            			}
HXLINE( 197)			Float angle = ::Math_obj::PI;
HXLINE( 198)			if ((numIterations == (int)0)) {
HXLINE( 199)				_gthis->tempPlane2->normal->setFrom(_gthis->tempPlane->normal);
HXLINE( 200)				_gthis->tempPlane2->constant = _gthis->tempPlane->constant;
            			}
            			else {
HXLINE( 203)				if ((numIterations <= maxRadialIterations)) {
HXLINE( 204)					angle = (((endAngle - startAngle) * (((Float)0.2) + (((Float)0.6) * ::Math_obj::random()))) + startAngle);
HXLINE( 207)					scope->tempVec42->setFrom(object->transform->loc)->sub(pointOfImpact)->applyAxisAngle(normal,angle)->add(pointOfImpact);
HXLINE( 208)					_gthis->tempPlane2->setFromCoplanarPoints(pointOfImpact,scope->tempVec4,scope->tempVec42);
            				}
            				else {
HXLINE( 211)					angle = (((((Float)0.5) * ((int)numIterations & (int)(int)1)) + (((Float)0.2) * ((int)2 - ::Math_obj::random()))) * ::Math_obj::PI);
HXLINE( 214)					scope->tempVec42->setFrom(pointOfImpact)->sub(subObject->transform->loc)->applyAxisAngle(normal,angle)->add(subObject->transform->loc);
HXLINE( 215)					scope->tempVec43->setFrom(normal)->add(subObject->transform->loc);
HXLINE( 216)					_gthis->tempPlane2->setFromCoplanarPoints(subObject->transform->loc,scope->tempVec43,scope->tempVec42);
            				}
            			}
HXLINE( 221)			scope->cutByPlane(subObject,_gthis->tempPlane2,scope->tempCutResult);
HXLINE( 223)			 ::iron::object::MeshObject object1 = scope->tempCutResult->object1;
HXLINE( 224)			 ::iron::object::MeshObject object2 = scope->tempCutResult->object2;
HXLINE( 225)			if (hx::IsNotNull( object1 )) {
HXLINE( 225)				subdivideRadial->__get((int)0)(object1,startAngle,angle,(numIterations + (int)1));
            			}
HXLINE( 226)			if (hx::IsNotNull( object2 )) {
HXLINE( 226)				subdivideRadial->__get((int)0)(object2,angle,endAngle,(numIterations + (int)1));
            			}
HXLINE( 229)			::iron::Scene_obj::active->meshes->remove(subObject);
            		}
            		HX_END_LOCAL_FUNC4((void))

            	HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_181_subdivideByImpact)
HXDLIN( 181)		 ::armory::trait::ConvexBreaker _gthis = hx::ObjectPtr<OBJ_>(this);
HXLINE( 182)		::Array< ::Dynamic> debris = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 184)		this->tempVec4->addvecs(pointOfImpact,normal);
HXLINE( 185)		this->tempPlane->setFromCoplanarPoints(pointOfImpact,object->transform->loc,this->tempVec4);
HXLINE( 187)		int maxTotalIterations = (maxRandomIterations + maxRadialIterations);
HXLINE( 188)		 ::armory::trait::ConvexBreaker scope = hx::ObjectPtr<OBJ_>(this);
HXLINE( 190)		::Array< ::Dynamic> subdivideRadial = ::Array_obj< ::Dynamic>::__new(1)->init(0,null());
HXDLIN( 190)		subdivideRadial[(int)0] =  ::Dynamic(new _hx_Closure_0(normal,_gthis,maxTotalIterations,scope,maxRadialIterations,pointOfImpact,debris,object,subdivideRadial));
HXDLIN( 190)		 ::Dynamic subdivideRadial1 = subdivideRadial->__get((int)0);
HXLINE( 232)		subdivideRadial1(object,(int)0,((int)2 * ::Math_obj::PI),(int)0);
HXLINE( 233)		return debris;
            	}


HX_DEFINE_DYNAMIC_FUNC5(ConvexBreaker_obj,subdivideByImpact,return )

 ::iron::math::Vec4 ConvexBreaker_obj::transformFreeVector( ::iron::math::Vec4 v, ::iron::math::Mat4 m){
            	HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_236_transformFreeVector)
HXLINE( 239)		float x = v->x;
HXDLIN( 239)		float y = v->y;
HXDLIN( 239)		float z = v->z;
HXLINE( 240)		float _hx_tmp = (m->self->_00 * x);
HXDLIN( 240)		float _hx_tmp1 = (_hx_tmp + (m->self->_10 * y));
HXDLIN( 240)		v->x = (_hx_tmp1 + (m->self->_20 * z));
HXLINE( 241)		float _hx_tmp2 = (m->self->_01 * x);
HXDLIN( 241)		float _hx_tmp3 = (_hx_tmp2 + (m->self->_11 * y));
HXDLIN( 241)		v->y = (_hx_tmp3 + (m->self->_21 * z));
HXLINE( 242)		float _hx_tmp4 = (m->self->_02 * x);
HXDLIN( 242)		float _hx_tmp5 = (_hx_tmp4 + (m->self->_12 * y));
HXDLIN( 242)		v->z = (_hx_tmp5 + (m->self->_22 * z));
HXLINE( 243)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ConvexBreaker_obj,transformFreeVector,return )

 ::iron::math::Vec4 ConvexBreaker_obj::transformFreeVectorInverse( ::iron::math::Vec4 v, ::iron::math::Mat4 m){
            	HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_246_transformFreeVectorInverse)
HXLINE( 249)		float x = v->x;
HXDLIN( 249)		float y = v->y;
HXDLIN( 249)		float z = v->z;
HXLINE( 250)		float _hx_tmp = (m->self->_00 * x);
HXDLIN( 250)		float _hx_tmp1 = (_hx_tmp + (m->self->_01 * y));
HXDLIN( 250)		v->x = (_hx_tmp1 + (m->self->_02 * z));
HXLINE( 251)		float _hx_tmp2 = (m->self->_10 * x);
HXDLIN( 251)		float _hx_tmp3 = (_hx_tmp2 + (m->self->_11 * y));
HXDLIN( 251)		v->y = (_hx_tmp3 + (m->self->_12 * z));
HXLINE( 252)		float _hx_tmp4 = (m->self->_20 * x);
HXDLIN( 252)		float _hx_tmp5 = (_hx_tmp4 + (m->self->_21 * y));
HXDLIN( 252)		v->z = (_hx_tmp5 + (m->self->_22 * z));
HXLINE( 253)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ConvexBreaker_obj,transformFreeVectorInverse,return )

 ::iron::math::Vec4 ConvexBreaker_obj::transformTiedVectorInverse( ::iron::math::Vec4 v, ::iron::math::Mat4 m){
            	HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_256_transformTiedVectorInverse)
HXLINE( 259)		float x = v->x;
HXDLIN( 259)		float y = v->y;
HXDLIN( 259)		float z = v->z;
HXLINE( 260)		float _hx_tmp = (m->self->_00 * x);
HXDLIN( 260)		float _hx_tmp1 = (_hx_tmp + (m->self->_01 * y));
HXDLIN( 260)		v->x = ((_hx_tmp1 + (m->self->_02 * z)) - m->self->_30);
HXLINE( 261)		float _hx_tmp2 = (m->self->_10 * x);
HXDLIN( 261)		float _hx_tmp3 = (_hx_tmp2 + (m->self->_11 * y));
HXDLIN( 261)		v->y = ((_hx_tmp3 + (m->self->_12 * z)) - m->self->_31);
HXLINE( 262)		float _hx_tmp4 = (m->self->_20 * x);
HXDLIN( 262)		float _hx_tmp5 = (_hx_tmp4 + (m->self->_21 * y));
HXDLIN( 262)		v->z = ((_hx_tmp5 + (m->self->_22 * z)) - m->self->_32);
HXLINE( 263)		return v;
            	}


HX_DEFINE_DYNAMIC_FUNC2(ConvexBreaker_obj,transformTiedVectorInverse,return )

void ConvexBreaker_obj::transformPlaneToLocalSpace( ::armory::trait::Plane plane, ::iron::math::Mat4 m, ::armory::trait::Plane resultPlane){
            	HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_266_transformPlaneToLocalSpace)
HXLINE( 267)		resultPlane->normal->setFrom(plane->normal);
HXLINE( 268)		resultPlane->constant = plane->constant;
HXLINE( 270)		 ::iron::math::Vec4 v1 =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE( 271)		 ::iron::math::Vec4 referencePoint = this->transformTiedVectorInverse(plane->coplanarPoint(v1),m);
HXLINE( 272)		this->transformFreeVectorInverse(resultPlane->normal,m);
HXLINE( 275)		resultPlane->constant = -(referencePoint->dot(resultPlane->normal));
            	}


HX_DEFINE_DYNAMIC_FUNC3(ConvexBreaker_obj,transformPlaneToLocalSpace,(void))

int ConvexBreaker_obj::cutByPlane( ::iron::object::MeshObject object, ::armory::trait::Plane plane, ::armory::trait::CutResult output){
            	HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_282_cutByPlane)
HXLINE( 283)		 ::armory::trait::UserData userData = this->userDataMap->get(object).StaticCast<  ::armory::trait::UserData >();
HXLINE( 284)		::Array< ::Dynamic> points = userData->vertices;
HXLINE( 285)		::Array< ::Dynamic> faces = userData->faces;
HXLINE( 287)		int numPoints = points->length;
HXLINE( 288)		::Array< ::Dynamic> points1 = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 289)		::Array< ::Dynamic> points2 = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 290)		Float delta = this->smallDelta;
HXLINE( 293)		{
HXLINE( 293)			int _g1 = (int)0;
HXDLIN( 293)			int _g = numPoints;
HXDLIN( 293)			while((_g1 < _g)){
HXLINE( 293)				_g1 = (_g1 + (int)1);
HXDLIN( 293)				int i = (_g1 - (int)1);
HXDLIN( 293)				points->__get(i).StaticCast<  ::iron::math::Vec4 >()->w = (int)0;
            			}
            		}
HXLINE( 296)		int numPointPairs = (numPoints * numPoints);
HXLINE( 297)		{
HXLINE( 297)			int _g11 = (int)0;
HXDLIN( 297)			int _g2 = numPointPairs;
HXDLIN( 297)			while((_g11 < _g2)){
HXLINE( 297)				_g11 = (_g11 + (int)1);
HXDLIN( 297)				int i1 = (_g11 - (int)1);
HXDLIN( 297)				this->segments[i1] = false;
            			}
            		}
HXLINE( 300)		{
HXLINE( 300)			int _g12 = (int)0;
HXDLIN( 300)			int _g3 = (faces->length - (int)1);
HXDLIN( 300)			while((_g12 < _g3)){
HXLINE( 300)				_g12 = (_g12 + (int)1);
HXDLIN( 300)				int i2 = (_g12 - (int)1);
HXLINE( 301)				 ::armory::trait::Face3 face1 = faces->__get(i2).StaticCast<  ::armory::trait::Face3 >();
HXLINE( 303)				{
HXLINE( 303)					int _g31 = (i2 + (int)1);
HXDLIN( 303)					int _g21 = faces->length;
HXDLIN( 303)					while((_g31 < _g21)){
HXLINE( 303)						_g31 = (_g31 + (int)1);
HXDLIN( 303)						int j = (_g31 - (int)1);
HXLINE( 304)						 ::armory::trait::Face3 face2 = faces->__get(j).StaticCast<  ::armory::trait::Face3 >();
HXLINE( 305)						bool coplanar = (((int)1 - face1->normal->dot(face2->normal)) < delta);
HXLINE( 307)						if (coplanar) {
HXLINE( 308)							int a1 = face1->a;
HXLINE( 309)							int b1 = face1->b;
HXLINE( 310)							int c1 = face1->c;
HXLINE( 311)							int a2 = face2->a;
HXLINE( 312)							int b2 = face2->b;
HXLINE( 313)							int c2 = face2->c;
HXLINE( 315)							bool _hx_tmp;
HXDLIN( 315)							bool _hx_tmp1;
HXDLIN( 315)							if ((a1 != a2)) {
HXLINE( 315)								_hx_tmp1 = (a1 == b2);
            							}
            							else {
HXLINE( 315)								_hx_tmp1 = true;
            							}
HXDLIN( 315)							if (!(_hx_tmp1)) {
HXLINE( 315)								_hx_tmp = (a1 == c2);
            							}
            							else {
HXLINE( 315)								_hx_tmp = true;
            							}
HXDLIN( 315)							if (_hx_tmp) {
HXLINE( 316)								bool _hx_tmp2;
HXDLIN( 316)								bool _hx_tmp3;
HXDLIN( 316)								if ((b1 != a2)) {
HXLINE( 316)									_hx_tmp3 = (b1 == b2);
            								}
            								else {
HXLINE( 316)									_hx_tmp3 = true;
            								}
HXDLIN( 316)								if (!(_hx_tmp3)) {
HXLINE( 316)									_hx_tmp2 = (b1 == c2);
            								}
            								else {
HXLINE( 316)									_hx_tmp2 = true;
            								}
HXDLIN( 316)								if (_hx_tmp2) {
HXLINE( 317)									::Array< bool > _hx_tmp4 = this->segments;
HXDLIN( 317)									_hx_tmp4[((a1 * numPoints) + b1)] = true;
HXLINE( 318)									::Array< bool > _hx_tmp5 = this->segments;
HXDLIN( 318)									_hx_tmp5[((b1 * numPoints) + a1)] = true;
            								}
            								else {
HXLINE( 321)									::Array< bool > _hx_tmp6 = this->segments;
HXDLIN( 321)									_hx_tmp6[((c1 * numPoints) + a1)] = true;
HXLINE( 322)									::Array< bool > _hx_tmp7 = this->segments;
HXDLIN( 322)									_hx_tmp7[((a1 * numPoints) + c1)] = true;
            								}
            							}
            							else {
HXLINE( 325)								bool _hx_tmp8;
HXDLIN( 325)								bool _hx_tmp9;
HXDLIN( 325)								if ((b1 != a2)) {
HXLINE( 325)									_hx_tmp9 = (b1 == b2);
            								}
            								else {
HXLINE( 325)									_hx_tmp9 = true;
            								}
HXDLIN( 325)								if (!(_hx_tmp9)) {
HXLINE( 325)									_hx_tmp8 = (b1 == c2);
            								}
            								else {
HXLINE( 325)									_hx_tmp8 = true;
            								}
HXDLIN( 325)								if (_hx_tmp8) {
HXLINE( 326)									::Array< bool > _hx_tmp10 = this->segments;
HXDLIN( 326)									_hx_tmp10[((c1 * numPoints) + b1)] = true;
HXLINE( 327)									::Array< bool > _hx_tmp11 = this->segments;
HXDLIN( 327)									_hx_tmp11[((b1 * numPoints) + c1)] = true;
            								}
            							}
            						}
            					}
            				}
            			}
            		}
HXLINE( 334)		 ::armory::trait::Plane localPlane = this->tempPlane;
HXLINE( 335)		object->transform->buildMatrix();
HXLINE( 336)		this->transformPlaneToLocalSpace(plane,object->transform->world,localPlane);
HXLINE( 339)		{
HXLINE( 339)			int _g13 = (int)0;
HXDLIN( 339)			int _g4 = faces->length;
HXDLIN( 339)			while((_g13 < _g4)){
HXLINE( 339)				_g13 = (_g13 + (int)1);
HXDLIN( 339)				int i3 = (_g13 - (int)1);
HXLINE( 341)				 ::armory::trait::Face3 face = faces->__get(i3).StaticCast<  ::armory::trait::Face3 >();
HXLINE( 342)				{
HXLINE( 342)					int _g22 = (int)0;
HXDLIN( 342)					while((_g22 < (int)3)){
HXLINE( 342)						_g22 = (_g22 + (int)1);
HXDLIN( 342)						int segment = (_g22 - (int)1);
HXLINE( 343)						int i0;
HXDLIN( 343)						if ((segment == (int)0)) {
HXLINE( 343)							i0 = face->a;
            						}
            						else {
HXLINE( 343)							if ((segment == (int)1)) {
HXLINE( 343)								i0 = face->b;
            							}
            							else {
HXLINE( 343)								i0 = face->c;
            							}
            						}
HXLINE( 344)						int i11;
HXDLIN( 344)						if ((segment == (int)0)) {
HXLINE( 344)							i11 = face->b;
            						}
            						else {
HXLINE( 344)							if ((segment == (int)1)) {
HXLINE( 344)								i11 = face->c;
            							}
            							else {
HXLINE( 344)								i11 = face->a;
            							}
            						}
HXLINE( 346)						::Array< bool > segmentState = this->segments;
HXDLIN( 346)						bool segmentState1 = segmentState->__get(((i0 * numPoints) + i11));
HXLINE( 348)						if (segmentState1) {
HXLINE( 348)							continue;
            						}
HXLINE( 351)						::Array< bool > _hx_tmp12 = this->segments;
HXDLIN( 351)						_hx_tmp12[((i0 * numPoints) + i11)] = true;
HXLINE( 352)						::Array< bool > _hx_tmp13 = this->segments;
HXDLIN( 352)						_hx_tmp13[((i11 * numPoints) + i0)] = true;
HXLINE( 354)						 ::iron::math::Vec4 p0 = points->__get(i0).StaticCast<  ::iron::math::Vec4 >();
HXLINE( 355)						 ::iron::math::Vec4 p1 = points->__get(i11).StaticCast<  ::iron::math::Vec4 >();
HXLINE( 357)						if ((p0->w == (int)0)) {
HXLINE( 358)							Float d = localPlane->distanceToPoint(p0);
HXLINE( 361)							if ((d > delta)) {
HXLINE( 362)								p0->w = (int)2;
HXLINE( 363)								points2->push(p0);
            							}
            							else {
HXLINE( 365)								if ((d < -(delta))) {
HXLINE( 366)									p0->w = (int)1;
HXLINE( 367)									points1->push(p0);
            								}
            								else {
HXLINE( 370)									p0->w = (int)3;
HXLINE( 371)									points1->push(p0);
HXLINE( 372)									 ::iron::math::Vec4 p02 = p0->clone();
HXLINE( 373)									p02->w = (int)3;
HXLINE( 374)									points2->push(p02);
            								}
            							}
            						}
HXLINE( 378)						if ((p1->w == (int)0)) {
HXLINE( 379)							Float d1 = localPlane->distanceToPoint(p1);
HXLINE( 382)							if ((d1 > delta)) {
HXLINE( 383)								p1->w = (int)2;
HXLINE( 384)								points2->push(p1);
            							}
            							else {
HXLINE( 386)								if ((d1 < -(delta))) {
HXLINE( 387)									p1->w = (int)1;
HXLINE( 388)									points1->push(p1);
            								}
            								else {
HXLINE( 391)									p1->w = (int)3;
HXLINE( 392)									points1->push(p1);
HXLINE( 393)									 ::iron::math::Vec4 p1_2 = p1->clone();
HXLINE( 394)									p1_2->w = (int)3;
HXLINE( 395)									points2->push(p1_2);
            								}
            							}
            						}
HXLINE( 399)						float mark0 = p0->w;
HXLINE( 400)						float mark1 = p1->w;
HXLINE( 402)						bool _hx_tmp14;
HXDLIN( 402)						bool _hx_tmp15;
HXDLIN( 402)						if ((mark0 == (int)1)) {
HXLINE( 402)							_hx_tmp15 = (mark1 == (int)2);
            						}
            						else {
HXLINE( 402)							_hx_tmp15 = false;
            						}
HXDLIN( 402)						if (!(_hx_tmp15)) {
HXLINE( 402)							if ((mark0 == (int)2)) {
HXLINE( 402)								_hx_tmp14 = (mark1 == (int)1);
            							}
            							else {
HXLINE( 402)								_hx_tmp14 = false;
            							}
            						}
            						else {
HXLINE( 402)							_hx_tmp14 = true;
            						}
HXDLIN( 402)						if (_hx_tmp14) {
HXLINE( 404)							this->tempLine->start->setFrom(p0);
HXLINE( 405)							this->tempLine->end->setFrom(p1);
HXLINE( 406)							 ::iron::math::Vec4 intersection = localPlane->intersectLine(this->tempLine);
HXLINE( 407)							if (hx::IsNull( intersection )) {
HXLINE( 407)								return (int)0;
            							}
HXLINE( 409)							intersection->w = (int)1;
HXLINE( 410)							points1->push(intersection);
HXLINE( 411)							 ::iron::math::Vec4 intersection_2 = intersection->clone();
HXLINE( 412)							intersection_2->w = (int)2;
HXLINE( 413)							points2->push(intersection_2);
            						}
            					}
            				}
            			}
            		}
HXLINE( 419)		Float newMass = (userData->mass * ((Float)0.5));
HXLINE( 422)		this->tempCM1->set((int)0,(int)0,(int)0,null());
HXLINE( 423)		Float radius1 = ((Float)0.0);
HXLINE( 424)		int numPoints1 = points1->length;
HXLINE( 425)		if ((numPoints1 > (int)0)) {
HXLINE( 426)			{
HXLINE( 426)				int _g14 = (int)0;
HXDLIN( 426)				int _g5 = numPoints1;
HXDLIN( 426)				while((_g14 < _g5)){
HXLINE( 426)					_g14 = (_g14 + (int)1);
HXDLIN( 426)					int i4 = (_g14 - (int)1);
HXLINE( 427)					 ::iron::math::Vec4 _hx_tmp16 = this->tempCM1;
HXDLIN( 427)					_hx_tmp16->add(points1->__get(i4).StaticCast<  ::iron::math::Vec4 >());
            				}
            			}
HXLINE( 429)			 ::iron::math::Vec4 _hx_tmp17 = this->tempCM1;
HXDLIN( 429)			_hx_tmp17->mult(((Float)((Float)1.0) / (Float)numPoints1));
HXLINE( 430)			{
HXLINE( 430)				int _g15 = (int)0;
HXDLIN( 430)				int _g6 = numPoints1;
HXDLIN( 430)				while((_g15 < _g6)){
HXLINE( 430)					_g15 = (_g15 + (int)1);
HXDLIN( 430)					int i5 = (_g15 - (int)1);
HXLINE( 431)					 ::iron::math::Vec4 p = points1->__get(i5).StaticCast<  ::iron::math::Vec4 >();
HXLINE( 432)					p->sub(this->tempCM1);
HXLINE( 433)					Float radius11 = ::Math_obj::max(radius1,p->x);
HXDLIN( 433)					radius1 = ::Math_obj::max(radius11,::Math_obj::max(p->y,p->z));
            				}
            			}
HXLINE( 435)			this->tempCM1->add(object->transform->loc);
            		}
HXLINE( 438)		this->tempCM2->set((int)0,(int)0,(int)0,null());
HXLINE( 439)		Float radius2 = ((Float)0.0);
HXLINE( 440)		int numPoints2 = points2->length;
HXLINE( 441)		if ((numPoints2 > (int)0)) {
HXLINE( 442)			{
HXLINE( 442)				int _g16 = (int)0;
HXDLIN( 442)				int _g7 = numPoints2;
HXDLIN( 442)				while((_g16 < _g7)){
HXLINE( 442)					_g16 = (_g16 + (int)1);
HXDLIN( 442)					int i6 = (_g16 - (int)1);
HXLINE( 443)					 ::iron::math::Vec4 _hx_tmp18 = this->tempCM2;
HXDLIN( 443)					_hx_tmp18->add(points2->__get(i6).StaticCast<  ::iron::math::Vec4 >());
            				}
            			}
HXLINE( 445)			 ::iron::math::Vec4 _hx_tmp19 = this->tempCM2;
HXDLIN( 445)			_hx_tmp19->mult(((Float)((Float)1.0) / (Float)numPoints2));
HXLINE( 446)			{
HXLINE( 446)				int _g17 = (int)0;
HXDLIN( 446)				int _g8 = numPoints2;
HXDLIN( 446)				while((_g17 < _g8)){
HXLINE( 446)					_g17 = (_g17 + (int)1);
HXDLIN( 446)					int i7 = (_g17 - (int)1);
HXLINE( 447)					 ::iron::math::Vec4 p2 = points2->__get(i7).StaticCast<  ::iron::math::Vec4 >();
HXLINE( 448)					p2->sub(this->tempCM2);
HXLINE( 449)					Float radius21 = ::Math_obj::max(radius2,p2->x);
HXDLIN( 449)					radius2 = ::Math_obj::max(radius21,::Math_obj::max(p2->y,p2->z));
            				}
            			}
HXLINE( 451)			this->tempCM2->add(object->transform->loc);
            		}
HXLINE( 454)		 ::iron::object::MeshObject object1 = null();
HXLINE( 455)		 ::iron::object::MeshObject object2 = null();
HXLINE( 456)		int numObjects = (int)0;
HXLINE( 457)		if ((numPoints1 > (int)4)) {
HXLINE( 458)			 ::iron::data::MeshData data1 = this->makeMeshData(points1);
HXLINE( 459)			object1 =  ::iron::object::MeshObject_obj::__alloc( HX_CTX ,data1,object->materials);
HXLINE( 460)			object1->transform->loc->setFrom(this->tempCM1);
HXLINE( 461)			object1->transform->rot->setFrom(object->transform->rot);
HXLINE( 462)			object1->transform->buildMatrix();
HXLINE( 463)			 ::iron::math::Vec4 userData1 = userData->velocity;
HXDLIN( 463)			 ::iron::math::Vec4 userData2 = userData->angularVelocity;
HXDLIN( 463)			this->initBreakableObject(object1,newMass,userData1,userData2,(((int)2 * radius1) > this->minSizeForBreak));
HXLINE( 464)			numObjects = (numObjects + (int)1);
            		}
HXLINE( 467)		if ((numPoints2 > (int)4)) {
HXLINE( 468)			 ::iron::data::MeshData data2 = this->makeMeshData(points2);
HXLINE( 469)			object2 =  ::iron::object::MeshObject_obj::__alloc( HX_CTX ,data2,object->materials);
HXLINE( 470)			object2->transform->loc->setFrom(this->tempCM2);
HXLINE( 471)			object2->transform->rot->setFrom(object->transform->rot);
HXLINE( 472)			object2->transform->buildMatrix();
HXLINE( 473)			 ::iron::math::Vec4 userData3 = userData->velocity;
HXDLIN( 473)			 ::iron::math::Vec4 userData4 = userData->angularVelocity;
HXDLIN( 473)			this->initBreakableObject(object2,newMass,userData3,userData4,(((int)2 * radius2) > this->minSizeForBreak));
HXLINE( 474)			numObjects = (numObjects + (int)1);
            		}
HXLINE( 477)		output->object1 = object1;
HXLINE( 478)		output->object2 = object2;
HXLINE( 479)		return numObjects;
            	}


HX_DEFINE_DYNAMIC_FUNC3(ConvexBreaker_obj,cutByPlane,return )

 ::iron::data::MeshData ConvexBreaker_obj::makeMeshData(::Array< ::Dynamic> points){
            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0,::Array< Float >,pa,::Array< Float >,na,::Array< int >,ind) HXARGC(2)
            		void _hx_run( ::iron::math::Vec4 normal,int fi){
            			HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_500_makeMeshData)
HXLINE( 500)			bool addFlatNormal1;
HXDLIN( 500)			bool addFlatNormal2;
HXDLIN( 500)			if ((na->__get((fi * (int)3)) == ((Float)0.0))) {
HXLINE( 500)				addFlatNormal2 = (na->__get(((fi * (int)3) + (int)1)) != ((Float)0.0));
            			}
            			else {
HXLINE( 500)				addFlatNormal2 = true;
            			}
HXDLIN( 500)			if (!(addFlatNormal2)) {
HXLINE( 500)				addFlatNormal1 = (na->__get(((fi * (int)3) + (int)2)) != ((Float)0.0));
            			}
            			else {
HXLINE( 500)				addFlatNormal1 = true;
            			}
HXDLIN( 500)			if (addFlatNormal1) {
HXLINE( 501)				pa->push(pa->__get((fi * (int)3)));
HXLINE( 502)				pa->push(pa->__get(((fi * (int)3) + (int)1)));
HXLINE( 503)				pa->push(pa->__get(((fi * (int)3) + (int)2)));
HXLINE( 504)				na->push(normal->x);
HXLINE( 505)				na->push(normal->y);
HXLINE( 506)				na->push(normal->z);
HXLINE( 507)				int addFlatNormal3 = ::Std_obj::_hx_int((((Float)pa->length / (Float)(int)3) - (int)1));
HXDLIN( 507)				ind->push(addFlatNormal3);
            			}
            			else {
HXLINE( 510)				na[(fi * (int)3)] = normal->x;
HXLINE( 511)				na[((fi * (int)3) + (int)1)] = normal->y;
HXLINE( 512)				na[((fi * (int)3) + (int)2)] = normal->z;
HXLINE( 513)				ind->push(fi);
            			}
            		}
            		HX_END_LOCAL_FUNC2((void))

            	HX_GC_STACKFRAME(&_hx_pos_a7abec19ed523c93_483_makeMeshData)
HXLINE( 484)		while((points->length > (int)50)){
HXLINE( 484)			points->pop().StaticCast<  ::iron::math::Vec4 >();
            		}
HXLINE( 485)		 ::armory::trait::ConvexHull cm =  ::armory::trait::ConvexHull_obj::__alloc( HX_CTX ,points);
HXLINE( 487)		::Array< Float > pa = ::Array_obj< Float >::__new();
HXLINE( 488)		::Array< Float > na = ::Array_obj< Float >::__new();
HXLINE( 489)		{
HXLINE( 489)			int _g = (int)0;
HXDLIN( 489)			::Array< ::Dynamic> _g1 = cm->vertices;
HXDLIN( 489)			while((_g < _g1->length)){
HXLINE( 489)				 ::iron::math::Vec4 p = _g1->__get(_g).StaticCast<  ::iron::math::Vec4 >();
HXDLIN( 489)				_g = (_g + (int)1);
HXLINE( 490)				pa->push(p->x);
HXLINE( 491)				pa->push(p->y);
HXLINE( 492)				pa->push(p->z);
HXLINE( 493)				na->push(((Float)0.0));
HXLINE( 494)				na->push(((Float)0.0));
HXLINE( 495)				na->push(((Float)0.0));
            			}
            		}
HXLINE( 498)		::Array< int > ind = ::Array_obj< int >::__new();
HXLINE( 499)		 ::Dynamic addFlatNormal =  ::Dynamic(new _hx_Closure_0(pa,na,ind));
HXLINE( 516)		{
HXLINE( 516)			int _g2 = (int)0;
HXDLIN( 516)			::Array< ::Dynamic> _g11 = cm->face3s;
HXDLIN( 516)			while((_g2 < _g11->length)){
HXLINE( 516)				 ::armory::trait::Face3 f = _g11->__get(_g2).StaticCast<  ::armory::trait::Face3 >();
HXDLIN( 516)				_g2 = (_g2 + (int)1);
HXLINE( 518)				addFlatNormal(f->normal,f->a);
HXLINE( 519)				addFlatNormal(f->normal,f->b);
HXLINE( 520)				addFlatNormal(f->normal,f->c);
            			}
            		}
HXLINE( 524)		 ::kha::arrays::Float32ArrayPrivate this1 =  ::kha::arrays::Float32ArrayPrivate_obj::__alloc( HX_CTX ,pa->length);
HXDLIN( 524)		 ::kha::arrays::Float32ArrayPrivate paa = this1;
HXLINE( 525)		{
HXLINE( 525)			int _g12 = (int)0;
HXDLIN( 525)			int _g3 = pa->length;
HXDLIN( 525)			while((_g12 < _g3)){
HXLINE( 525)				_g12 = (_g12 + (int)1);
HXDLIN( 525)				int i = (_g12 - (int)1);
HXDLIN( 525)				 float32array paa1 = paa->self;
HXDLIN( 525)				paa1.set(i,pa->__get(i));
            			}
            		}
HXLINE( 526)		 ::kha::arrays::Float32ArrayPrivate this2 =  ::kha::arrays::Float32ArrayPrivate_obj::__alloc( HX_CTX ,na->length);
HXDLIN( 526)		 ::kha::arrays::Float32ArrayPrivate naa = this2;
HXLINE( 527)		{
HXLINE( 527)			int _g13 = (int)0;
HXDLIN( 527)			int _g4 = na->length;
HXDLIN( 527)			while((_g13 < _g4)){
HXLINE( 527)				_g13 = (_g13 + (int)1);
HXDLIN( 527)				int i1 = (_g13 - (int)1);
HXDLIN( 527)				 float32array naa1 = naa->self;
HXDLIN( 527)				naa1.set(i1,na->__get(i1));
            			}
            		}
HXLINE( 528)		 ::kha::arrays::Uint32ArrayPrivate this3 =  ::kha::arrays::Uint32ArrayPrivate_obj::__alloc( HX_CTX ,ind->length);
HXDLIN( 528)		 ::kha::arrays::Uint32ArrayPrivate inda = this3;
HXLINE( 529)		{
HXLINE( 529)			int _g14 = (int)0;
HXDLIN( 529)			int _g5 = ind->length;
HXDLIN( 529)			while((_g14 < _g5)){
HXLINE( 529)				_g14 = (_g14 + (int)1);
HXDLIN( 529)				int i2 = (_g14 - (int)1);
HXDLIN( 529)				 uint32array inda1 = inda->self;
HXDLIN( 529)				inda1.set(i2,ind->__get(i2));
            			}
            		}
HXLINE( 531)		 ::Dynamic pos =  ::Dynamic(hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("attrib",4a,e7,1c,e0),HX_("pos",94,5d,55,00))
            			->setFixed(1,HX_("size",c1,a0,53,4c),(int)3)
            			->setFixed(2,HX_("values",e2,03,b7,4f),paa));
HXLINE( 537)		 ::Dynamic nor =  ::Dynamic(hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("attrib",4a,e7,1c,e0),HX_("nor",11,d9,53,00))
            			->setFixed(1,HX_("size",c1,a0,53,4c),(int)3)
            			->setFixed(2,HX_("values",e2,03,b7,4f),naa));
HXLINE( 543)		 ::Dynamic indices =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("material",a7,5c,a5,f0),(int)0)
            			->setFixed(1,HX_("values",e2,03,b7,4f),inda));
HXLINE( 548)		 ::Dynamic rawmesh =  ::Dynamic(hx::Anon_obj::Create(3)
            			->setFixed(0,HX_("index_arrays",87,55,78,a3),::Array_obj< ::Dynamic>::__new(1)->init(0,indices))
            			->setFixed(1,HX_("vertex_arrays",75,a3,55,cb),::Array_obj< ::Dynamic>::__new(2)->init(0,pos)->init(1,nor))
            			->setFixed(2,HX_("name",4b,72,ff,48),(HX_("TempMesh",41,0f,7f,71) + ::armory::trait::ConvexBreaker_obj::meshIndex++)));
HXLINE( 554)		 ::iron::data::MeshData md = ::iron::data::MeshData_obj::newSync(rawmesh);
HXLINE( 555)		md->geom->calculateAABB();
HXLINE( 556)		return md;
            	}


HX_DEFINE_DYNAMIC_FUNC1(ConvexBreaker_obj,makeMeshData,return )

int ConvexBreaker_obj::meshIndex;


hx::ObjectPtr< ConvexBreaker_obj > ConvexBreaker_obj::__new(hx::Null< Float >  __o_minSizeForBreak,hx::Null< Float >  __o_smallDelta) {
	hx::ObjectPtr< ConvexBreaker_obj > __this = new ConvexBreaker_obj();
	__this->__construct(__o_minSizeForBreak,__o_smallDelta);
	return __this;
}

hx::ObjectPtr< ConvexBreaker_obj > ConvexBreaker_obj::__alloc(hx::Ctx *_hx_ctx,hx::Null< Float >  __o_minSizeForBreak,hx::Null< Float >  __o_smallDelta) {
	ConvexBreaker_obj *__this = (ConvexBreaker_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(ConvexBreaker_obj), true, "armory.trait.ConvexBreaker"));
	*(void **)__this = ConvexBreaker_obj::_hx_vtable;
	__this->__construct(__o_minSizeForBreak,__o_smallDelta);
	return __this;
}

ConvexBreaker_obj::ConvexBreaker_obj()
{
}

void ConvexBreaker_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ConvexBreaker);
	HX_MARK_MEMBER_NAME(minSizeForBreak,"minSizeForBreak");
	HX_MARK_MEMBER_NAME(smallDelta,"smallDelta");
	HX_MARK_MEMBER_NAME(tempLine,"tempLine");
	HX_MARK_MEMBER_NAME(tempPlane,"tempPlane");
	HX_MARK_MEMBER_NAME(tempPlane2,"tempPlane2");
	HX_MARK_MEMBER_NAME(tempCM1,"tempCM1");
	HX_MARK_MEMBER_NAME(tempCM2,"tempCM2");
	HX_MARK_MEMBER_NAME(tempVec4,"tempVec4");
	HX_MARK_MEMBER_NAME(tempVec42,"tempVec42");
	HX_MARK_MEMBER_NAME(tempVec43,"tempVec43");
	HX_MARK_MEMBER_NAME(tempCutResult,"tempCutResult");
	HX_MARK_MEMBER_NAME(segments,"segments");
	HX_MARK_MEMBER_NAME(userDataMap,"userDataMap");
	HX_MARK_END_CLASS();
}

void ConvexBreaker_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(minSizeForBreak,"minSizeForBreak");
	HX_VISIT_MEMBER_NAME(smallDelta,"smallDelta");
	HX_VISIT_MEMBER_NAME(tempLine,"tempLine");
	HX_VISIT_MEMBER_NAME(tempPlane,"tempPlane");
	HX_VISIT_MEMBER_NAME(tempPlane2,"tempPlane2");
	HX_VISIT_MEMBER_NAME(tempCM1,"tempCM1");
	HX_VISIT_MEMBER_NAME(tempCM2,"tempCM2");
	HX_VISIT_MEMBER_NAME(tempVec4,"tempVec4");
	HX_VISIT_MEMBER_NAME(tempVec42,"tempVec42");
	HX_VISIT_MEMBER_NAME(tempVec43,"tempVec43");
	HX_VISIT_MEMBER_NAME(tempCutResult,"tempCutResult");
	HX_VISIT_MEMBER_NAME(segments,"segments");
	HX_VISIT_MEMBER_NAME(userDataMap,"userDataMap");
}

hx::Val ConvexBreaker_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"tempCM1") ) { return hx::Val( tempCM1 ); }
		if (HX_FIELD_EQ(inName,"tempCM2") ) { return hx::Val( tempCM2 ); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tempLine") ) { return hx::Val( tempLine ); }
		if (HX_FIELD_EQ(inName,"tempVec4") ) { return hx::Val( tempVec4 ); }
		if (HX_FIELD_EQ(inName,"segments") ) { return hx::Val( segments ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tempPlane") ) { return hx::Val( tempPlane ); }
		if (HX_FIELD_EQ(inName,"tempVec42") ) { return hx::Val( tempVec42 ); }
		if (HX_FIELD_EQ(inName,"tempVec43") ) { return hx::Val( tempVec43 ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"smallDelta") ) { return hx::Val( smallDelta ); }
		if (HX_FIELD_EQ(inName,"tempPlane2") ) { return hx::Val( tempPlane2 ); }
		if (HX_FIELD_EQ(inName,"cutByPlane") ) { return hx::Val( cutByPlane_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"userDataMap") ) { return hx::Val( userDataMap ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"makeMeshData") ) { return hx::Val( makeMeshData_dyn() ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"tempCutResult") ) { return hx::Val( tempCutResult ); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"minSizeForBreak") ) { return hx::Val( minSizeForBreak ); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"subdivideByImpact") ) { return hx::Val( subdivideByImpact_dyn() ); }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"initBreakableObject") ) { return hx::Val( initBreakableObject_dyn() ); }
		if (HX_FIELD_EQ(inName,"transformFreeVector") ) { return hx::Val( transformFreeVector_dyn() ); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"transformFreeVectorInverse") ) { return hx::Val( transformFreeVectorInverse_dyn() ); }
		if (HX_FIELD_EQ(inName,"transformTiedVectorInverse") ) { return hx::Val( transformTiedVectorInverse_dyn() ); }
		if (HX_FIELD_EQ(inName,"transformPlaneToLocalSpace") ) { return hx::Val( transformPlaneToLocalSpace_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool ConvexBreaker_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"meshIndex") ) { outValue = ( meshIndex ); return true; }
	}
	return false;
}

hx::Val ConvexBreaker_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"tempCM1") ) { tempCM1=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tempCM2") ) { tempCM2=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"tempLine") ) { tempLine=inValue.Cast<  ::armory::trait::Line3 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tempVec4") ) { tempVec4=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"segments") ) { segments=inValue.Cast< ::Array< bool > >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"tempPlane") ) { tempPlane=inValue.Cast<  ::armory::trait::Plane >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tempVec42") ) { tempVec42=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tempVec43") ) { tempVec43=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"smallDelta") ) { smallDelta=inValue.Cast< Float >(); return inValue; }
		if (HX_FIELD_EQ(inName,"tempPlane2") ) { tempPlane2=inValue.Cast<  ::armory::trait::Plane >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"userDataMap") ) { userDataMap=inValue.Cast<  ::haxe::ds::ObjectMap >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"tempCutResult") ) { tempCutResult=inValue.Cast<  ::armory::trait::CutResult >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"minSizeForBreak") ) { minSizeForBreak=inValue.Cast< Float >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ConvexBreaker_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"meshIndex") ) { meshIndex=ioValue.Cast< int >(); return true; }
	}
	return false;
}

void ConvexBreaker_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("minSizeForBreak","\x89","\xa3","\x58","\xd6"));
	outFields->push(HX_HCSTRING("smallDelta","\xb1","\x35","\x48","\x02"));
	outFields->push(HX_HCSTRING("tempLine","\x28","\x21","\x27","\x97"));
	outFields->push(HX_HCSTRING("tempPlane","\xa8","\x02","\xa2","\xfa"));
	outFields->push(HX_HCSTRING("tempPlane2","\x8a","\x50","\x20","\x53"));
	outFields->push(HX_HCSTRING("tempCM1","\xb3","\x7b","\xad","\x46"));
	outFields->push(HX_HCSTRING("tempCM2","\xb4","\x7b","\xad","\x46"));
	outFields->push(HX_HCSTRING("tempVec4","\x94","\x30","\xc0","\x9d"));
	outFields->push(HX_HCSTRING("tempVec42","\x1e","\x51","\x6a","\x6a"));
	outFields->push(HX_HCSTRING("tempVec43","\x1f","\x51","\x6a","\x6a"));
	outFields->push(HX_HCSTRING("tempCutResult","\x4b","\x8a","\x16","\xf9"));
	outFields->push(HX_HCSTRING("segments","\x60","\xed","\x26","\x4e"));
	outFields->push(HX_HCSTRING("userDataMap","\x87","\x67","\xf5","\xd7"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo ConvexBreaker_obj_sMemberStorageInfo[] = {
	{hx::fsFloat,(int)offsetof(ConvexBreaker_obj,minSizeForBreak),HX_HCSTRING("minSizeForBreak","\x89","\xa3","\x58","\xd6")},
	{hx::fsFloat,(int)offsetof(ConvexBreaker_obj,smallDelta),HX_HCSTRING("smallDelta","\xb1","\x35","\x48","\x02")},
	{hx::fsObject /*::armory::trait::Line3*/ ,(int)offsetof(ConvexBreaker_obj,tempLine),HX_HCSTRING("tempLine","\x28","\x21","\x27","\x97")},
	{hx::fsObject /*::armory::trait::Plane*/ ,(int)offsetof(ConvexBreaker_obj,tempPlane),HX_HCSTRING("tempPlane","\xa8","\x02","\xa2","\xfa")},
	{hx::fsObject /*::armory::trait::Plane*/ ,(int)offsetof(ConvexBreaker_obj,tempPlane2),HX_HCSTRING("tempPlane2","\x8a","\x50","\x20","\x53")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(ConvexBreaker_obj,tempCM1),HX_HCSTRING("tempCM1","\xb3","\x7b","\xad","\x46")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(ConvexBreaker_obj,tempCM2),HX_HCSTRING("tempCM2","\xb4","\x7b","\xad","\x46")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(ConvexBreaker_obj,tempVec4),HX_HCSTRING("tempVec4","\x94","\x30","\xc0","\x9d")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(ConvexBreaker_obj,tempVec42),HX_HCSTRING("tempVec42","\x1e","\x51","\x6a","\x6a")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(ConvexBreaker_obj,tempVec43),HX_HCSTRING("tempVec43","\x1f","\x51","\x6a","\x6a")},
	{hx::fsObject /*::armory::trait::CutResult*/ ,(int)offsetof(ConvexBreaker_obj,tempCutResult),HX_HCSTRING("tempCutResult","\x4b","\x8a","\x16","\xf9")},
	{hx::fsObject /*Array< bool >*/ ,(int)offsetof(ConvexBreaker_obj,segments),HX_HCSTRING("segments","\x60","\xed","\x26","\x4e")},
	{hx::fsObject /*::haxe::ds::ObjectMap*/ ,(int)offsetof(ConvexBreaker_obj,userDataMap),HX_HCSTRING("userDataMap","\x87","\x67","\xf5","\xd7")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo ConvexBreaker_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &ConvexBreaker_obj::meshIndex,HX_HCSTRING("meshIndex","\xe5","\xa5","\x34","\xf6")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String ConvexBreaker_obj_sMemberFields[] = {
	HX_HCSTRING("minSizeForBreak","\x89","\xa3","\x58","\xd6"),
	HX_HCSTRING("smallDelta","\xb1","\x35","\x48","\x02"),
	HX_HCSTRING("tempLine","\x28","\x21","\x27","\x97"),
	HX_HCSTRING("tempPlane","\xa8","\x02","\xa2","\xfa"),
	HX_HCSTRING("tempPlane2","\x8a","\x50","\x20","\x53"),
	HX_HCSTRING("tempCM1","\xb3","\x7b","\xad","\x46"),
	HX_HCSTRING("tempCM2","\xb4","\x7b","\xad","\x46"),
	HX_HCSTRING("tempVec4","\x94","\x30","\xc0","\x9d"),
	HX_HCSTRING("tempVec42","\x1e","\x51","\x6a","\x6a"),
	HX_HCSTRING("tempVec43","\x1f","\x51","\x6a","\x6a"),
	HX_HCSTRING("tempCutResult","\x4b","\x8a","\x16","\xf9"),
	HX_HCSTRING("segments","\x60","\xed","\x26","\x4e"),
	HX_HCSTRING("userDataMap","\x87","\x67","\xf5","\xd7"),
	HX_HCSTRING("initBreakableObject","\x48","\x78","\x56","\xc6"),
	HX_HCSTRING("subdivideByImpact","\x16","\x10","\x04","\xb0"),
	HX_HCSTRING("transformFreeVector","\x1b","\x3b","\xb1","\xda"),
	HX_HCSTRING("transformFreeVectorInverse","\xd5","\xa1","\x50","\x01"),
	HX_HCSTRING("transformTiedVectorInverse","\x6d","\x58","\x47","\x67"),
	HX_HCSTRING("transformPlaneToLocalSpace","\x26","\x7e","\xc4","\x4e"),
	HX_HCSTRING("cutByPlane","\xa3","\xc3","\x6f","\x21"),
	HX_HCSTRING("makeMeshData","\xc5","\x5a","\x3e","\x11"),
	::String(null()) };

static void ConvexBreaker_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ConvexBreaker_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(ConvexBreaker_obj::meshIndex,"meshIndex");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ConvexBreaker_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ConvexBreaker_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(ConvexBreaker_obj::meshIndex,"meshIndex");
};

#endif

hx::Class ConvexBreaker_obj::__mClass;

static ::String ConvexBreaker_obj_sStaticFields[] = {
	HX_HCSTRING("meshIndex","\xe5","\xa5","\x34","\xf6"),
	::String(null())
};

void ConvexBreaker_obj::__register()
{
	hx::Object *dummy = new ConvexBreaker_obj;
	ConvexBreaker_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("armory.trait.ConvexBreaker","\x31","\x10","\x16","\xe2");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ConvexBreaker_obj::__GetStatic;
	__mClass->mSetStaticField = &ConvexBreaker_obj::__SetStatic;
	__mClass->mMarkFunc = ConvexBreaker_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(ConvexBreaker_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ConvexBreaker_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ConvexBreaker_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ConvexBreaker_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ConvexBreaker_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ConvexBreaker_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ConvexBreaker_obj::__boot()
{
{
            	HX_STACKFRAME(&_hx_pos_a7abec19ed523c93_482_boot)
HXDLIN( 482)		meshIndex = (int)0;
            	}
}

} // end namespace armory
} // end namespace trait
