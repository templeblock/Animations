// Generated by Haxe 3.4.4
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_armory_trait_Character
#include <armory/trait/Character.h>
#endif
#ifndef INCLUDED_iron_Trait
#include <iron/Trait.h>
#endif
#ifndef INCLUDED_iron_math_Mat4
#include <iron/math/Mat4.h>
#endif
#ifndef INCLUDED_iron_math_Vec4
#include <iron/math/Vec4.h>
#endif
#ifndef INCLUDED_iron_object_Animation
#include <iron/object/Animation.h>
#endif
#ifndef INCLUDED_iron_object_Object
#include <iron/object/Object.h>
#endif
#ifndef INCLUDED_iron_object_Transform
#include <iron/object/Transform.h>
#endif
#ifndef INCLUDED_kha_math_FastMatrix4
#include <kha/math/FastMatrix4.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_332b546652be9627_10_new,"armory.trait.Character","new",0xd38b2f07,"armory.trait.Character.new","armory/trait/Character.hx",10,0xf35b600b)
HX_LOCAL_STACK_FRAME(_hx_pos_332b546652be9627_34_init,"armory.trait.Character","init",0x42f6ae89,"armory.trait.Character.init","armory/trait/Character.hx",34,0xf35b600b)
HX_LOCAL_STACK_FRAME(_hx_pos_332b546652be9627_48_update,"armory.trait.Character","update",0xe09f89c2,"armory.trait.Character.update","armory/trait/Character.hx",48,0xf35b600b)
namespace armory{
namespace trait{

void Character_obj::__construct(::String actionIdle,::String actionMove){
            	HX_GC_STACKFRAME(&_hx_pos_332b546652be9627_10_new)
HXLINE(  20)		this->framesIdle = (int)0;
HXLINE(  19)		this->lastLoc = null();
HXLINE(  18)		this->loc =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,null(),null(),null(),null());
HXLINE(  17)		this->speed = ((Float)0.0);
HXLINE(  23)		super::__construct();
HXLINE(  25)		bool _hx_tmp;
HXDLIN(  25)		if (hx::IsNotNull( actionIdle )) {
HXLINE(  25)			_hx_tmp = hx::IsNotNull( actionMove );
            		}
            		else {
HXLINE(  25)			_hx_tmp = false;
            		}
HXDLIN(  25)		if (_hx_tmp) {
HXLINE(  26)			this->actionIdle = actionIdle;
HXLINE(  27)			this->actionMove = actionMove;
HXLINE(  28)			this->currentAction = actionIdle;
            		}
HXLINE(  31)		this->notifyOnInit(this->init_dyn());
            	}

Dynamic Character_obj::__CreateEmpty() { return new Character_obj; }

void *Character_obj::_hx_vtable = 0;

Dynamic Character_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Character_obj > _hx_result = new Character_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Character_obj::_hx_isInstanceOf(int inClassId) {
	if (inClassId<=(int)0x355cb615) {
		return inClassId==(int)0x00000001 || inClassId==(int)0x355cb615;
	} else {
		return inClassId==(int)0x7b609ac2;
	}
}

void Character_obj::init(){
            	HX_STACKFRAME(&_hx_pos_332b546652be9627_34_init)
HXLINE(  35)		this->animation = this->object->animation;
HXLINE(  38)		if (hx::IsNull( this->animation )) {
HXLINE(  39)			if ((this->object->children->length > (int)0)) {
HXLINE(  40)				this->animation = this->object->children->__get((int)0).StaticCast<  ::iron::object::Object >()->animation;
            			}
            		}
HXLINE(  44)		if (hx::IsNull( this->animation )) {
HXLINE(  44)			return;
            		}
HXLINE(  45)		this->notifyOnUpdate(this->update_dyn());
            	}


HX_DEFINE_DYNAMIC_FUNC0(Character_obj,init,(void))

void Character_obj::update(){
            	HX_GC_STACKFRAME(&_hx_pos_332b546652be9627_48_update)
HXLINE(  50)		 ::iron::object::Transform tr = this->object->transform;
HXLINE(  51)		this->loc->set(tr->world->self->_30,tr->world->self->_31,tr->world->self->_32,null());
HXLINE(  54)		if (hx::IsNull( this->lastLoc )) {
HXLINE(  54)			this->lastLoc =  ::iron::math::Vec4_obj::__alloc( HX_CTX ,this->loc->x,this->loc->y,this->loc->z,null());
            		}
HXLINE(  57)		 ::iron::math::Vec4 v1 = this->loc;
HXDLIN(  57)		 ::iron::math::Vec4 v2 = this->lastLoc;
HXDLIN(  57)		float vx = (v1->x - v2->x);
HXDLIN(  57)		float vy = (v1->y - v2->y);
HXDLIN(  57)		float vz = (v1->z - v2->z);
HXDLIN(  57)		this->speed = ::Math_obj::sqrt((((vx * vx) + (vy * vy)) + (vz * vz)));
HXLINE(  61)		this->lastLoc->setFrom(this->loc);
HXLINE(  63)		if ((this->speed == (int)0)) {
HXLINE(  63)			this->framesIdle++;
            		}
            		else {
HXLINE(  64)			this->framesIdle = (int)0;
            		}
HXLINE(  67)		bool _hx_tmp;
HXDLIN(  67)		if ((this->currentAction == this->actionIdle)) {
HXLINE(  67)			_hx_tmp = (this->framesIdle == (int)0);
            		}
            		else {
HXLINE(  67)			_hx_tmp = false;
            		}
HXDLIN(  67)		if (_hx_tmp) {
HXLINE(  68)			this->currentAction = this->actionMove;
HXLINE(  70)			if (hx::IsNotNull( this->actionMove )) {
HXLINE(  70)				this->animation->play(this->actionMove,null(),null(),null(),null());
            			}
            		}
            		else {
HXLINE(  74)			bool _hx_tmp1;
HXDLIN(  74)			if ((this->currentAction == this->actionMove)) {
HXLINE(  74)				_hx_tmp1 = (this->framesIdle > (int)2);
            			}
            			else {
HXLINE(  74)				_hx_tmp1 = false;
            			}
HXDLIN(  74)			if (_hx_tmp1) {
HXLINE(  75)				this->currentAction = this->actionIdle;
HXLINE(  77)				if (hx::IsNotNull( this->actionIdle )) {
HXLINE(  77)					this->animation->play(this->actionIdle,null(),null(),null(),null());
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Character_obj,update,(void))


hx::ObjectPtr< Character_obj > Character_obj::__new(::String actionIdle,::String actionMove) {
	hx::ObjectPtr< Character_obj > __this = new Character_obj();
	__this->__construct(actionIdle,actionMove);
	return __this;
}

hx::ObjectPtr< Character_obj > Character_obj::__alloc(hx::Ctx *_hx_ctx,::String actionIdle,::String actionMove) {
	Character_obj *__this = (Character_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(Character_obj), true, "armory.trait.Character"));
	*(void **)__this = Character_obj::_hx_vtable;
	__this->__construct(actionIdle,actionMove);
	return __this;
}

Character_obj::Character_obj()
{
}

void Character_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Character);
	HX_MARK_MEMBER_NAME(actionIdle,"actionIdle");
	HX_MARK_MEMBER_NAME(actionMove,"actionMove");
	HX_MARK_MEMBER_NAME(currentAction,"currentAction");
	HX_MARK_MEMBER_NAME(animation,"animation");
	HX_MARK_MEMBER_NAME(speed,"speed");
	HX_MARK_MEMBER_NAME(loc,"loc");
	HX_MARK_MEMBER_NAME(lastLoc,"lastLoc");
	HX_MARK_MEMBER_NAME(framesIdle,"framesIdle");
	 ::iron::Trait_obj::__Mark(HX_MARK_ARG);
	HX_MARK_END_CLASS();
}

void Character_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(actionIdle,"actionIdle");
	HX_VISIT_MEMBER_NAME(actionMove,"actionMove");
	HX_VISIT_MEMBER_NAME(currentAction,"currentAction");
	HX_VISIT_MEMBER_NAME(animation,"animation");
	HX_VISIT_MEMBER_NAME(speed,"speed");
	HX_VISIT_MEMBER_NAME(loc,"loc");
	HX_VISIT_MEMBER_NAME(lastLoc,"lastLoc");
	HX_VISIT_MEMBER_NAME(framesIdle,"framesIdle");
	 ::iron::Trait_obj::__Visit(HX_VISIT_ARG);
}

hx::Val Character_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"loc") ) { return hx::Val( loc ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"init") ) { return hx::Val( init_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { return hx::Val( speed ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"update") ) { return hx::Val( update_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"lastLoc") ) { return hx::Val( lastLoc ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"animation") ) { return hx::Val( animation ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"actionIdle") ) { return hx::Val( actionIdle ); }
		if (HX_FIELD_EQ(inName,"actionMove") ) { return hx::Val( actionMove ); }
		if (HX_FIELD_EQ(inName,"framesIdle") ) { return hx::Val( framesIdle ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentAction") ) { return hx::Val( currentAction ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val Character_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"loc") ) { loc=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"speed") ) { speed=inValue.Cast< Float >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"lastLoc") ) { lastLoc=inValue.Cast<  ::iron::math::Vec4 >(); return inValue; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"animation") ) { animation=inValue.Cast<  ::iron::object::Animation >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"actionIdle") ) { actionIdle=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"actionMove") ) { actionMove=inValue.Cast< ::String >(); return inValue; }
		if (HX_FIELD_EQ(inName,"framesIdle") ) { framesIdle=inValue.Cast< int >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentAction") ) { currentAction=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void Character_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("actionIdle","\xea","\x21","\xfa","\x50"));
	outFields->push(HX_HCSTRING("actionMove","\xe7","\x5d","\xa7","\x53"));
	outFields->push(HX_HCSTRING("currentAction","\xcf","\xbc","\xa2","\xf9"));
	outFields->push(HX_HCSTRING("animation","\x04","\xef","\x34","\x4b"));
	outFields->push(HX_HCSTRING("speed","\x87","\x97","\x69","\x81"));
	outFields->push(HX_HCSTRING("loc","\x80","\x54","\x52","\x00"));
	outFields->push(HX_HCSTRING("lastLoc","\xca","\x9b","\xa7","\xd7"));
	outFields->push(HX_HCSTRING("framesIdle","\xda","\x4d","\x9a","\xb7"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo Character_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(Character_obj,actionIdle),HX_HCSTRING("actionIdle","\xea","\x21","\xfa","\x50")},
	{hx::fsString,(int)offsetof(Character_obj,actionMove),HX_HCSTRING("actionMove","\xe7","\x5d","\xa7","\x53")},
	{hx::fsString,(int)offsetof(Character_obj,currentAction),HX_HCSTRING("currentAction","\xcf","\xbc","\xa2","\xf9")},
	{hx::fsObject /*::iron::object::Animation*/ ,(int)offsetof(Character_obj,animation),HX_HCSTRING("animation","\x04","\xef","\x34","\x4b")},
	{hx::fsFloat,(int)offsetof(Character_obj,speed),HX_HCSTRING("speed","\x87","\x97","\x69","\x81")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(Character_obj,loc),HX_HCSTRING("loc","\x80","\x54","\x52","\x00")},
	{hx::fsObject /*::iron::math::Vec4*/ ,(int)offsetof(Character_obj,lastLoc),HX_HCSTRING("lastLoc","\xca","\x9b","\xa7","\xd7")},
	{hx::fsInt,(int)offsetof(Character_obj,framesIdle),HX_HCSTRING("framesIdle","\xda","\x4d","\x9a","\xb7")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *Character_obj_sStaticStorageInfo = 0;
#endif

static ::String Character_obj_sMemberFields[] = {
	HX_HCSTRING("actionIdle","\xea","\x21","\xfa","\x50"),
	HX_HCSTRING("actionMove","\xe7","\x5d","\xa7","\x53"),
	HX_HCSTRING("currentAction","\xcf","\xbc","\xa2","\xf9"),
	HX_HCSTRING("animation","\x04","\xef","\x34","\x4b"),
	HX_HCSTRING("speed","\x87","\x97","\x69","\x81"),
	HX_HCSTRING("loc","\x80","\x54","\x52","\x00"),
	HX_HCSTRING("lastLoc","\xca","\x9b","\xa7","\xd7"),
	HX_HCSTRING("framesIdle","\xda","\x4d","\x9a","\xb7"),
	HX_HCSTRING("init","\x10","\x3b","\xbb","\x45"),
	HX_HCSTRING("update","\x09","\x86","\x05","\x87"),
	::String(null()) };

static void Character_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Character_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Character_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Character_obj::__mClass,"__mClass");
};

#endif

hx::Class Character_obj::__mClass;

void Character_obj::__register()
{
	hx::Object *dummy = new Character_obj;
	Character_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("armory.trait.Character","\x95","\x9f","\x5f","\x18");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Character_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Character_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Character_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Character_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Character_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Character_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace armory
} // end namespace trait
